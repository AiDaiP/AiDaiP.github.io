---
layout: post
title:  "DES基本操作"
date:   2019-7-11
desc: ""
keywords: ""
categories: [Crypto]
tags: [Crypto,DES]
icon: icon-html
---

# DES基本操作

* #### 基本操作

  ![7](https://raw.githubusercontent.com/AiDaiP/images/master/des/7.png)

* #### IP置换表

  ![2](https://raw.githubusercontent.com/AiDaiP/images/master/des/2.png)

  

  

* #### 扩展运算

  ![4](https://raw.githubusercontent.com/AiDaiP/images/master/des/4.png)

  方框内为32bit原始数据，扩展后为48bit

* #### S盒置换

  ![5](https://raw.githubusercontent.com/AiDaiP/images/master/des/5.png)

  ![8](https://raw.githubusercontent.com/AiDaiP/images/master/des/8.png)

  ![6](https://raw.githubusercontent.com/AiDaiP/images/master/des/6.png)

  输入6bit，第一位和第六位组成一个二进制数对应S盒中的行号，三四五位组成一个二进制数对应S盒中的列号，交叉点的数据是是该盒的输出

  对于上图S1盒，输入0b101011，输出0b1001

  * ##### S盒设计准则

    1. 每个S盒均为6位输入，4位输出。
    2.  没有一个S盒的输出位是接近输入位的线性函数。
    3. 如果将输入位的最左、最右端的位固定，变化中间的4位，每个可能的4位输出只得到一次.4）如果S盒的两个输入仅有1位的差异，则其输出必须至少有2位不同.5）如果S盒的两个输入仅有中间2位不同，则其输出必须至少有2位不同。
    4. 如果S盒的两个输入前2位不同，后两位已知，则其输出必不同。
    5. 对于输入之间的任何非零的6位差分，32对中至多有8对显示出的差分导致了相同的输出差分。

* #### P盒置换

  ![9](https://raw.githubusercontent.com/AiDaiP/images/master/des/9.png)

  把输入的每位映射到输出位

  输入0001 0000 1010 0001 0000 0000 0000 0001

  输出1000 0000 0000 0000 0000 1000 1000 0110

  * ##### P盒设计准则

    1. 在第i轮S盒的4位输出中，2位将影响S盒第i+1轮的中间位，其余2位将影响最后位。
    2. 每个S盒的4位输出影响6个不同的S盒，但没有一个影响同一个S盒。
    3. 如果一个S盒的4位输出影响另一个S盒的中间1位，那么后一个的输出位不会影响前一个S盒的中间1位。

* #### 子密钥生成

  ![10](https://raw.githubusercontent.com/AiDaiP/images/master/des/10.png)

  ![11](https://raw.githubusercontent.com/AiDaiP/images/master/des/11.png)

* #### 3DES

  使用三个密钥，执行三次DES算法

  加密过程：加密-解密-加密

  $C=Ek_3(Dk_2(Ek_1(P))) $

  解密过程：解密-加密-解密 

  $P=Dk_1(EK_2(Dk_3(C))) $

* #### 加密模式

  * #####  ECB

    电子密本方式，将数据按照8个字节一组分组进行DES加密或解密，之后按顺序连接

  * ##### CBC

    将数据按8个字节一组分组

    第一组数据与向量I异或后的结果进行DES加密得到第一组密文C1

    第二组数据与C1异或后的结果进行DES加密得到第二组密文C2

    以此类推，最后将密文按顺序连接

    * 加密：

      $ C_1 = Enc(Key, XOR(IV, P_1) $

      $C_i = Enc(Key, XOR(C_{i-1}, P_i) $

    * 解密

      $P_1 = XOR(IV, Dec(Key, C_1)) $

      $ P_i = XOR(C_{i-1}, Dec(Key,C_i)) $

    * 特点

      - 每次加密的密文长度为64位(8个字节)
      - 当相同的明文使用相同的密钥和初始向量的时候CBC模式总是产生相同的密文
      - 密文块要依赖以前的操作结果,所以，密文块不能进行重新排列
      - 可以使用不同的初始化向量来避免相同的明文产生相同的密文,一定程度上抵抗字典攻击
      - 一个错误发生以后,当前和以后的密文都会被影响

  * ##### CFB

    ![12](https://raw.githubusercontent.com/AiDaiP/images/master/des/12.png)

    * 加密

      $S_0 = IV$

      $O_i = Enc(Key, S_i)$

      $C_i = XOR( P_i, Lef(O_i))$

      $ S_i = A(S_{i-1}, C_i) $

    * 解密

      $S_0 = IV$

      $O_i = Enc(Key, S_i)$

      $P_i = XOR( C_i, Lef(O_i))$

      $ S_i = A(S_{i-1}, C_i)$

    $Lef(x)​$表示取x最左8位

    $A(x,y)$表示x左移8位，空位用y填充

    * 特点
      - 每次加密的Pi和Ci不大于64位
      - 加密算法和解密算法相同，不能适用于公钥算法
      - 使用相同的密钥和初始向量的时候，相同明文使用CFB模式加密输出相同的密文
      - 可以使用不同的初始化变量使相同的明文产生不同的密文，防止字典攻击
      - 加密强度依赖于密钥长度
      - 加密块长度过小时,会增加循环的数量,导致开销增加
      - 加密块长度应时8位的整数倍(即字节为单位)
      - 一旦某位数据出错,会影响目前和其后8个块的数据

  * ##### OFB

    ![13](https://raw.githubusercontent.com/AiDaiP/images/master/des/13.png)

    - 加密

      $S_0 = IV$

      $O_i = Enc(Key, S_i)$

      $C_i = XOR( P_i, Lef(O_i))​$

      $ S_i = A(S_{i-1}, O_i) $

    - 解密

      $S_0 = IV$

      $O_i = Enc(Key, S_i)$

      $P_i = XOR( C_i, Lef(O_i))$

      $ S_i = A(S_{i-1}, O_i)$

    - 特点

      - 因为密文没有参与链操作，所以使得OFB模式更容易受到攻击
      - 不会进行错误传播，某位密文发生错误，只会影响该位对应的明文，而不会影响别的位
      - 不是自同步的，如果加密和解密两个操作失去同步，那么系统需要重新初始化
      - 每次重新同步时，应使用不同的初始向量。可以避免产生相同的比特流，避免”已知明文”攻击 

* #### 填充

  * ##### ZeroPadding 

    数据长度不对齐时使用0填充，否则不填充。

  * ##### PKCS7Padding

    假设数据长度需要填充n(n>0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小。 

  * ##### PKCS5Padding 

    PKCS7Padding的子集，块大小固定为8字节。

    

```python
from Crypto.Cipher import DES
from Crypto import Random
import base64
def encrypt(key, raw):
    iv = Random.new().read(DES.block_size)
    cipher = DES.new(key, DES.MODE_OFB, iv)
    return base64.b64encode(iv + cipher.encrypt(raw.encode("utf-8")))

def decrypt(key, enc):
    enc = base64.b64decode(enc)
    iv = enc[:DES.block_size]
    cipher = DES.new(key, DES.MODE_OFB, iv)
    return cipher.decrypt(enc[DES.block_size:]).decode("utf-8")

```

