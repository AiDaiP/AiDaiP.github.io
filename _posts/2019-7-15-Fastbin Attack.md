---
layout: post
title:  "Fastbin Attack"
date:   2019-7-15
desc: ""
keywords: ""
categories: [Binary]
tags: [pwn]
icon: icon-html
---

# Fastbin Attack

![11](https://raw.githubusercontent.com/AiDaiP/images/master/pwn/11.png)

- ##### 条件

  1. 存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞
  2. 漏洞发生于 fastbin 类型的 chunk 中

- ##### 原理

  ```c
  int main(void)
  {
      void *chunk1,*chunk2,*chunk3;
      chunk1=malloc(0x30);
      chunk2=malloc(0x30);
      chunk3=malloc(0x30);
      free(chunk1);
      free(chunk2);
      free(chunk3);
      printf("gg");
      return 0;
  }
  ```

  free前

  ```c
  pwndbg> x/64gx 0x8402250
  0x8402250:      0x0000000000000000      0x0000000000000041 <=== chunk1
  0x8402260:      0x0000000000000000      0x0000000000000000
  0x8402270:      0x0000000000000000      0x0000000000000000
  0x8402280:      0x0000000000000000      0x0000000000000000
  0x8402290:      0x0000000000000000      0x0000000000000041 <=== chunk2
  0x84022a0:      0x0000000000000000      0x0000000000000000
  0x84022b0:      0x0000000000000000      0x0000000000000000
  0x84022c0:      0x0000000000000000      0x0000000000000000
  0x84022d0:      0x0000000000000000      0x0000000000000041 <=== chunk3
  0x84022e0:      0x0000000000000000      0x0000000000000000
  0x84022f0:      0x0000000000000000      0x0000000000000000
  0x8402300:      0x0000000000000000      0x0000000000000000
  0x8402310:      0x0000000000000000      0x0000000000020cf1 <=== top chunk
  ```

  free后

  ```c
  pwndbg> x/64gx 0x8402250
  0x8402250:      0x0000000000000000      0x0000000000000041 <=== chunk1
  0x8402260:      0x0000000000000000      0x0000000000000000
  0x8402270:      0x0000000000000000      0x0000000000000000
  0x8402280:      0x0000000000000000      0x0000000000000000
  0x8402290:      0x0000000000000000      0x0000000000000041 <=== chunk2
  0x84022a0:      0x0000000008402260      0x0000000000000000
  0x84022b0:      0x0000000000000000      0x0000000000000000
  0x84022c0:      0x0000000000000000      0x0000000000000000
  0x84022d0:      0x0000000000000000      0x0000000000000041 <=== chunk3
  0x84022e0:      0x00000000084022a0      0x0000000000000000
  0x84022f0:      0x0000000000000000      0x0000000000000000
  0x8402300:      0x0000000000000000      0x0000000000000000
  0x8402310:      0x0000000000000000      0x0000000000020cf1 <=== top chunk
  
  chunk3 ==> chunk2 ==> chunk1
  ```

  

- ##### Fastbin Double Free

  * 产生原因
    1. fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空
    2. fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。

  ```c
  int main(void)
  {
      void *chunk1,*chunk2;
      chunk1=malloc(0x10);
      chunk2=malloc(0x10);
      free(chunk1);
      free(chunk1);
      printf("gg");
      return 0;
  }
  ```

  free前

  ```c
  pwndbg> x/64gx 0x8402250
  0x8402250:      0x0000000000000000      0x0000000000000021 <=== chunk1
  0x8402260:      0x0000000000000000      0x0000000000000000
  0x8402270:      0x0000000000000000      0x0000000000000021 <=== chunk2
  0x8402280:      0x0000000000000000      0x0000000000000000
  0x8402290:      0x0000000000000000      0x0000000000020d71 <=== top chunk
  ```

  free后

  ```c
  pwndbg> x/64gx 0x8402250
  0x8402250:      0x0000000000000000      0x0000000000000021 <=== chunk1
  0x8402260:      0x0000000008402260      0x0000000000000000
  0x8402270:      0x0000000000000000      0x0000000000000021 <=== chunk2
  0x8402280:      0x0000000000000000      0x0000000000000000
  0x8402290:      0x0000000000000000      0x0000000000020d71 <=== top chunk
  
  chunk1 —▸ chunk1
  ```

  

  ```c
  int main(void)
  {
      void *chunk1,*chunk2;
      chunk1=malloc(0x10);
      chunk2=malloc(0x10);
      free(chunk1);
      free(chunk2);
      free(chunk1);
      printf("gg");
      return 0;
  }
  ```

  free前

  ```c
  pwndbg> x/64gx 0x8402250
  0x8402250:      0x0000000000000000      0x0000000000000021 <=== chunk1
  0x8402260:      0x0000000000000000      0x0000000000000000
  0x8402270:      0x0000000000000000      0x0000000000000021 <=== chunk2
  0x8402280:      0x0000000000000000      0x0000000000000000
  0x8402290:      0x0000000000000000      0x0000000000020d71 <=== top chunk
  ```

  free

  ```c
  第一次free
  pwndbg> x/64gx 0x8402250
  0x8402250:      0x0000000000000000      0x0000000000000021 <=== chunk1
  0x8402260:      0x0000000000000000      0x0000000000000000
  0x8402270:      0x0000000000000000      0x0000000000000021 <=== chunk2
  0x8402280:      0x0000000000000000      0x0000000000000000
  0x8402290:      0x0000000000000000      0x0000000000020d71 <=== top chunk
  
  第二次free
  pwndbg> x/64gx 0x8402250
  0x8402250:      0x0000000000000000      0x0000000000000021 <=== chunk1
  0x8402260:      0x0000000000000000      0x0000000000000000
  0x8402270:      0x0000000000000000      0x0000000000000021 <=== chunk2
  0x8402280:      0x0000000008402260      0x0000000000000000
  0x8402290:      0x0000000000000000      0x0000000000020d71 <=== top chunk
  
  第三次free
  pwndbg> x/64gx 0x8402250
  0x8402250:      0x0000000000000000      0x0000000000000021 <=== chunk1
  0x8402260:      0x0000000008402280      0x0000000000000000
  0x8402270:      0x0000000000000000      0x0000000000000021 <=== chunk2
  0x8402280:      0x0000000008402260      0x0000000000000000
  0x8402290:      0x0000000000000000      0x0000000000020d71 <=== top chunk
  
  chunk1 ==> chunk2 ==> chunk1
  ```

- #### House Of Spirit

  在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的

  * ##### 绕过检测

    1. fake chunk 的 ISMMAP 位不能为 1 -
    2. fake chunk 地址需要对齐 
    3. fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。
    4. fake chunk 的 next chunk 的大小不能小于 `2 * SIZE_SZ`，同时也不能大于`av->system_mem`。
    5. fake chunk 对应的 fastbin 链表头部不能是该 fake chunk。

- #### Alloc to Stack

  把 fd 指针指向想要分配的栈上，从而实现控制栈中的一些关键数据 

  

- #### Arbitrary Alloc

  把 chunk 分配到任意存在合法的 size 域的可写内存中 

  
