---
layout: post
title:  "De1CTF2019-Writeup"
date:   2019-8-6
desc: ""
keywords: ""
categories: [Ctf]
tags: [CTF,De1CTF]
icon: icon-html
---

# De1CTF2019-Writeup

* ### Mine Sweeping 

  dnSpy打开Assembly-CSharp.dll

  找到MineAt，根据洋文判断这是设定地雷的方法

  返回值决定是否有雷，直接该成return false

  打开游戏随便一点就过关![1](https://raw.githubusercontent.com/AiDaiP/images/master/de1ctf/1.png)





* ### xorz

  ```python
  from itertools import *
  from data import flag,plain
  key=flag.strip("de1ctf{").strip("}")
  assert(len(key<38))
  salt="WeAreDe1taTeam"
  ki=cycle(key)
  si=cycle(salt)
  cipher = ''.join([hex(ord(p) ^ ord(next(ki)) ^ ord(next(si)))[2:].zfill(2) for p in plain])
  print cipher
  ```

  Many Time Pad

  密文先和盐异或一波得到明文和密钥异或的结果

  然后根据明文都是可打印字符爆破密钥长度

  ```python
  flag_chars = string.letters + string.digits+'_'
  chars = string.printable
  a = 
  b = 
  for t in range(1,37):
  	num = 0
  	step = t*2
  	print(step)
  	for i in flag_chars:
  		nmsl = False
  		for j in range(0, len(a), step):
  			fuck = a[j:j+step]
  			if(len(fuck)<b):
  				continue
  			if chr(ord(i)^int(fuck[a:b],16)) not in chars:
  				nmsl = True
  				break
  		if nmsl == True:
  			continue
  		else:
  			num+=1
  			print(i)
  	if num != 0:
  		list.append(t)
  print(list)
  ```

  俺寻思手动爆破挺快

  得到密钥长度只能为30

  按照密钥长度对明文和密钥异或的结果分组，然后跑明文

  原理是c1⊕c2 = m1⊕m2，通过m1⊕m2可以分析出m1和m2 

  https://github.com/Jwomers/many-time-pad-attack

  ```python
  ## OTP - Recovering the private key from a set of messages that were encrypted w/ the same private key (Many time pad attack) - crypto100-many_time_secret @ alexctf 2017
  # Original code by jwomers: https://github.com/Jwomers/many-time-pad-attack/blob/master/attack.py)
  
  import string
  import collections
  import sets, sys
  
  # 11 unknown ciphertexts (in hex format), all encrpyted with the same key
  
  c1='1e5d4c055104471c6f234f5501555b5a014e5d001c2a54470555064c443e'
  c2='235b4c0e590356542a130a4242335a47551a590a136f1d5d4d440b095677'
  c3='3613180b5f184015210e4f541c075a47064e5f001e2a4f711844430c473e'
  c4='2413011a100556153d1e4f45061441151901470a196f035b0c4443185b32'
  c5='2e130806431d5a072a46385901555c5b550a541c1a2600564d5f054c453e'
  c6='32444c0a434d43182a0b1c540a55415a550a5e1b0f613a5c1f10021e5677'
  c7='3a5a0206100852063c4a18581a1d15411d17111b052113460850104c4722'
  c8='39564c0755015a13271e0a55553b5a47551a54010e2a06130b5506005a39'
  c9='3013180c100f52072a4a1b5e1b165d50064e411d0521111f235f114c4736'
  c10='2447094f10035c066f19025402191915110b4206182a544702100109133e'
  c11='394505175509671b6f0b01484e06505b061b50034a2911521e44431b5a23'
  c12='3f13180b5508131523050154403740415503484f0c2602564d470a18407b'
  c13='775d031110004a54290319544e06505b060b424f092e1a77044310195233'
  c14='3213030d554d551b2006064206555d50141c454f0c3d1b5e4d43061e453e'
  c15='39544c17580856581802001102105443101d111a043c03521455074c473f'
  c16='3213000a5b085d113c194f5e08555415180f5f433e270d131d420c195777'
  c17='3f560d11440d40543c060e470b55545b114e470e193c155f4d4711094734'
  c18='3f13180c100f565a000403484e184c15050250081f2a54470545104c5536'
  c19='251325435302461a3b4a02484e12545c1b4265070b3b5440055543185b36'
  c20='231301025b084054220f4f42071b1554020f430b196f19564d4002055d79'
  
  ciphers = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11,c12,c13,c14,c15,c16,c17,c18,c19,c20]
  # The target ciphertext we want to crack
  #target_cipher = "0529242a631234122d2b36697f13272c207f2021283a6b0c7908"
  
  # XORs two string
  def strxor(a, b):     # xor two strings (trims the longer input)
      return "".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])
  
  def target_fix(target_cipher):
      # To store the final key
      final_key = [None]*150
      # To store the positions we know are broken
      known_key_positions = set()
  
      # For each ciphertext
      for current_index, ciphertext in enumerate(ciphers):
          counter = collections.Counter()
          # for each other ciphertext
          for index, ciphertext2 in enumerate(ciphers):
              if current_index != index: # don't xor a ciphertext with itself
                  for indexOfChar, char in enumerate(strxor(ciphertext.decode('hex'), ciphertext2.decode('hex'))): # Xor the two ciphertexts
                      # If a character in the xored result is a alphanumeric character, it means there was probably a space character in one of the plaintexts (we don't know which one)
                      if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 # Increment the counter at this index
          knownSpaceIndexes = []
  
          # Loop through all positions where a space character was possible in the current_index cipher
          for ind, val in counter.items():
              # If a space was found at least 7 times at this index out of the 9 possible XORS, then the space character was likely from the current_index cipher!
              if val >= 7: knownSpaceIndexes.append(ind)
          #print knownSpaceIndexes # Shows all the positions where we now know the key!
  
          # Now Xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back!
          xor_with_spaces = strxor(ciphertext.decode('hex'),' '*150)
          for index in knownSpaceIndexes:
              # Store the key's value at the correct position
              final_key[index] = xor_with_spaces[index].encode('hex')
              # Record that we known the key at this position
              known_key_positions.add(index)
  
      # Construct a hex key from the currently known key, adding in '00' hex chars where we do not know (to make a complete hex string)
      final_key_hex = ''.join([val if val is not None else '00' for val in final_key])
      # Xor the currently known key with the target cipher
      output = strxor(target_cipher.decode('hex'),final_key_hex.decode('hex'))
  
      print "Fix this sentence:"
      print ''.join([char if index in known_key_positions else '*' for index, char in enumerate(output)])+"\n"
  
      # WAIT.. MANUAL STEP HERE 
      # This output are printing a * if that character is not known yet
      # fix the missing characters like this: "Let*M**k*ow if *o{*a" = "cure, Let Me know if you a"
      # if is too hard, change the target_cipher to another one and try again
      # and we have our key to fix the entire text!
  
      #sys.exit(0) #comment and continue if u got a good key
      target_plaintext = "In faith I do not love thee wi"
      print "Fixed:"
      print target_plaintext+"\n"
  
      key = strxor(target_cipher.decode('hex'),target_plaintext)
  
      print "Decrypted msg:"
      for cipher in ciphers:
          print strxor(cipher.decode('hex'),key)
  
      print "\nPrivate key recovered: "+key+"\n"
  
  
  for i in ciphers:
      target_fix(i)
  ```

  其实这是个填字游戏

  还学了一波洋文单词

  ```
  Fix this sentence:
  In faith I d& not,lcve thee wg
  
  Fixed:
  In faith I do not love thee wi
  
  Decrypted msg:
  In faith I do not love thee wi
  th mine eyes,For they in thee
  a thousand errors note;But `ti
  s my heart that loves what the
  y despise,Who in despite of vi
  ew is pleased to dote.Nor are
  mine ears with thy tongue`s tu
  ne delighted;Nor tender feelin
  g to base touches prone,Nor ta
  ste, nor smell, desire to be i
  nvitedTo any sensual feast wit
  h thee alone.But my five wits,
   nor my five senses canDissuad
  e one foolish heart from servi
  ng thee,Who leaves unswayed th
  e likeness of a man,Thy proud
  heart`s slave and vassal wretc
  h to be.Only my plague thus fa
  r I count my gain,That she tha
  t makes me sin awards me pain.
  
  Private key recovered: W3lc0m3tOjo1nu55un1ojOt3m0cl3W
  ```



* ### A+B Judge 

  * ### 非预期解

    我寻思直接cat就完事了

    ![3](https://raw.githubusercontent.com/AiDaiP/images/master/de1ctf/3.png)

    ![2](https://raw.githubusercontent.com/AiDaiP/images/master/de1ctf/2.png)

    白给

  * ### 预期解

    syscall绕过限制，读取flag

    

* ### Baby Rsa

  ```python
  import binascii
  from data import e1,e2,p,q1p,q1q,hint,flag
  
  n =  [20129615352491765499340112943188317180548761597861300847305827141510465619670536844634558246439230371658836928103063432870245707180355907194284861510906071265352409579441048101084995923962148527097370705452070577098780246282820065573711015664291991372085157016901209114191068574208680397710042842835940428451949500607613634682684113208766694028789275748528254287705759528498986306494267817198340658241873024800336013946294891687591013414935237821291805123285905335762719823771647853378892868896078424572232934360940672962436849523915563328779942134504499568866135266628078485232098208237036724121481835035731201383423L, 31221650155627849964466413749414700613823841060149524451234901677160009099014018926581094879840097248543411980533066831976617023676225625067854003317018794041723612556008471579060428898117790587991055681380408263382761841625714415879087478072771968160384909919958010983669368360788505288855946124159513118847747998656422521414980295212646675850690937883764000571667574381419144372824211798018586804674824564606122592483286575800685232128273820087791811663878057827386379787882962763290066072231248814920468264741654086011072638211075445447843691049847262485759393290853117072868406861840793895816215956869523289231421L, 29944537515397953361520922774124192605524711306753835303703478890414163510777460559798334313021216389356251874917792007638299225821018849648520673813786772452822809546571129816310207232883239771324122884804993418958309460009406342872173189008449237959577469114158991202433476710581356243815713762802478454390273808377430685157110095496727966308001254107517967559384019734279861840997239176254236069001453544559786063915970071130087811123912044312219535513880663913831358790376650439083660611831156205113873793106880255882114422025746986403355066996567909581710647746463994280444700922867397754748628425967488232530303L, 25703437855600135215185778453583925446912731661604054184163883272265503323016295700357253105301146726667897497435532579974951478354570415554221401778536104737296154316056314039449116386494323668483749833147800557403368489542273169489080222009368903993658498263905567516798684211462607069796613434661148186901892016282065916190920443378756167250809872483501712225782004396969996983057423942607174314132598421269169722518224478248836881076484639837343079324636997145199835034833367743079935361276149990997875905313642775214486046381368619638551892292787783137622261433528915269333426768947358552919740901860982679180791L]
  c =  [19131432661217908470262338421299691998526157790583544156741981238822158563988520225986915234570037383888112724408392918113942721994125505014727545946133307329781747600302829588248042922635714391033431930411180545085316438084317927348705241927570432757892985091396044950085462429575440060652967253845041398399648442340042970814415571904057667028157512971079384601724816308078631844480110201787343583073815186771790477712040051157180318804422120472007636722063989315320863580631330647116993819777750684150950416298085261478841177681677867236865666207391847046483954029213495373613490690687473081930148461830425717614569L, 15341898433226638235160072029875733826956799982958107910250055958334922460202554924743144122170018355117452459472017133614642242411479849369061482860570279863692425621526056862808425135267608544855833358314071200687340442512856575278712986641573012456729402660597339609443771145347181268285050728925993518704899005416187250003304581230701444705157412790787027926810710998646191467130550713600765898234392350153965811595060656753711278308005193370936296124790772689433773414703645703910742193898471800081321469055211709339846392500706523670145259024267858368216902176489814789679472227343363035428541915118378163012031L, 18715065071648040017967211297231106538139985087685358555650567057715550586464814763683688299037897182845007578571401359061213777645114414642903077003568155508465819628553747173244235936586812445440095450755154357646737087071605811984163416590278352605433362327949048243722556262979909488202442530307505819371594747936223835233586945423522256938701002370646382097846105014981763307729234675737702252155130837154876831885888669150418885088089324534892506199724486783446267336789872782137895552509353583305880144947714110009893134162185382309992604435664777436197587312317224862723813510974493087450281755452428746194446L, 2282284561224858293138480447463319262474918847630148770112472703128549032592187797289965592615199709857879008271766433462032328498580340968871260189669707518557157836592424973257334362931639831072584824103123486522582531666152363874396482744561758133655406410364442174983227005501860927820871260711861008830120617056883514525798709601744088135999465598338635794275123149165498933580159945032363880613524921913023341209439657145962332213468573402863796920571812418200814817086234262280338221161622789516829363805084715652121739036183264026120868756523770196284142271849879003202190966150390061195469351716819539183797L]
  f=lambda m,e,n,c:pow(m,e,n)==c
  assert(sum(map(f,[p]*4,[4]*4,n,c))==4)
  
  ee1 = 42
  ee2 = 3
  ce1 =  45722651786340123946960815003059322528810481841378247280642868553607692149509126962872583037142461398806689489141741494974836882341505234255325683219092163052843461632338442529011502378931140356111756932712822516814023166068902569458299933391973504078898958921809723346229893913662577294963528318424676803942288386430172430880307619748186863890050113934573820505570928109017842647598266634344447182347849367714564686341871007505886728393751147033556889217604647355628557502208364412269944908011305064122941446516990168924709684092200183860653173856272384
  ce2 =  13908468332333567158469136439932325992349696889129103935400760239319454409539725389747059213835238373047899198211128689374049729578146875309231962936554403287882999967840346216695208424582739777034261079550395918048421086843927009452479936045850799096750074359160775182238980989229190157551197830879877097703347301072427149474991803868325769967332356950863518504965486565464059770451458557744949735282131727956056279292800694203866167270268988437389945703117070604488999247750139568614939965885211276821987586882908159585863514561191905040244967655444219603287214405014887994238259270716355378069726760953320025828158
  tmp =  864078778078609835167779565982540757684070450697854309005171742813414963447462554999012718960925081621571487444725528982424037419052194840720949809891134854871222612682162490991065015935449289960707882463387
  n  =  15911581555796798614711625288508309704791837516232122410440958830726078821069050404012820896260071751380436992710638364294658173571101596931605797509712839622479368850251206419748090059752427303611760004621378226431226983665746837779056271530181865648115862947527212787824629516204832313026456390047768174765687040950636530480549014401279054346098030395100387004111574278813749630986724706263655166289586230453975953773791945408589484679371854113457758157492241225180907090235116325034822993748409011554673180494306003272836905082473475046277554085737627846557240367696214081276345071055578169299060706794192776825039
  assert(pow(e1,ee1,n)==ce1)
  assert(pow(e2+tmp,ee2,n)==ce2)
  
  e = 46531
  n = 16278524034278364842964386062476113517067911891699789991355982121084973951738324063305190630865511554888330215827724887964565979607808294168282995825864982603759381323048907814961279012375346497781046417204954101076457350988751188332353062731641153547102721113593787978587135707313755661153376485647168543680503160420091693269984008764444291289486805840439906620313162344057956594836197521501755378387944609246120662335790110901623740990451586621846212047950084207251595169141015645449217847180683357626383565631317253913942886396494396189837432429078251573229378917400841832190737518763297323901586866664595327850603
  c = 14992132140996160330967307558503117255626925777426611978518339050671013041490724616892634911030918360867974894371539160853827180596100892180735770688723270765387697604426715670445270819626709364566478781273676115921657967761494619448095207169386364541164659123273236874649888236433399127407801843412677293516986398190165291102109310458304626261648346825196743539220198199366711858135271877662410355585767124059539217274691606825103355310348607611233052725805236763220343249873849646219850954945346791015858261715967952461021650307307454434510851869862964236227932964442289459508441345652423088404453536608812799355469
  hint=int(binascii.hexlify(hint),16)
  assert(q1p*q1q==n)
  assert(q1p<q1q)
  assert(c==pow(hint,e,n))
  
  flag=int(binascii.hexlify(flag),16)
  q2 =  114401188227479584680884046151299704656920536168767132916589182357583461053336386996123783294932566567773695426689447410311969456458574731187512974868297092638677515283584994416382872450167046416573472658841627690987228528798356894803559278308702635288537653192098514966089168123710854679638671424978221959513
  c1 =  262739975753930281690942784321252339035906196846340713237510382364557685379543498765074448825799342194332681181129770046075018122033421983227887719610112028230603166527303021036386350781414447347150383783816869784006598225583375458609586450854602862569022571672049158809874763812834044257419199631217527367046624888837755311215081173386523806086783266198390289097231168172692326653657393522561741947951887577156666663584249108899327053951891486355179939770150550995812478327735917006194574412518819299303783243886962455399783601229227718787081785391010424030509937403600351414176138124705168002288620664809270046124
  c2 =  7395591129228876649030819616685821899204832684995757724924450812977470787822266387122334722132760470911599176362617225218345404468270014548817267727669872896838106451520392806497466576907063295603746660003188440170919490157250829308173310715318925771643105064882620746171266499859049038016902162599261409050907140823352990750298239508355767238575709803167676810456559665476121149766947851911064706646506705397091626648713684511780456955453552020460909638016134124590438425738826828694773960514221910109473941451471431637903182205738738109429736425025621308300895473186381826756650667842656050416299166317372707709596
  assert(c1==pow(flag,e1,p*q1))
  assert(c2==pow(flag,e2,p*q2))
  ```

  广播攻击先搞出来p

  https://github.com/Aqcurate/Broadcast-Attack

  ```
  p = 109935857933867829728985398563235455481120300859311421762540858762721955038310117609456763338082237907005937380873151279351831600225270995344096532750271070807051984097524900957809427861441436796934012393707770012556604479065826879107677002380580866325868240270494148512743861326447181476633546419262340100453
  ```

  ee2 = 3，小公钥指数攻击搞一波

  ```python
  def small_exponent():
  	N = 15911581555796798614711625288508309704791837516232122410440958830726078821069050404012820896260071751380436992710638364294658173571101596931605797509712839622479368850251206419748090059752427303611760004621378226431226983665746837779056271530181865648115862947527212787824629516204832313026456390047768174765687040950636530480549014401279054346098030395100387004111574278813749630986724706263655166289586230453975953773791945408589484679371854113457758157492241225180907090235116325034822993748409011554673180494306003272836905082473475046277554085737627846557240367696214081276345071055578169299060706794192776825039
  	e = 3
  	c = 13908468332333567158469136439932325992349696889129103935400760239319454409539725389747059213835238373047899198211128689374049729578146875309231962936554403287882999967840346216695208424582739777034261079550395918048421086843927009452479936045850799096750074359160775182238980989229190157551197830879877097703347301072427149474991803868325769967332356950863518504965486565464059770451458557744949735282131727956056279292800694203866167270268988437389945703117070604488999247750139568614939965885211276821987586882908159585863514561191905040244967655444219603287214405014887994238259270716355378069726760953320025828158
  	i = 0
  	while 1:
  		print(i)
  		if(gmpy.root(c+i*N, 3)[1]==1):
  			plaintext = gmpy.root(c+i*N, 3)[0]
  			break
  		i += 1
  	print(plaintext)
  	
  small_exponent()
  #e2 = 381791429275130
  ```

  猜测e1不大，直接对cc1开42次方看一下

  ```
  >>> gmpy.root(ce1,42)
  (mpz(15218928658178), 1)
  ```

  开不出来，不过试一下15218928658178

  ```
  >>> pow(15218928658178,ee1,n)==ce1
  True
  #e = 15218928658178
  ```

  然后q1p和q1q

  猜测q1p和p1q相差过大或过小，上yafu

  分解成功

  ```
  q1q = 127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088835693
  q1p = 127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088834871
  ```

  现在数据齐了

  求一波flag，发现e1和φ(n1)不互素，e2和φ(n2)不互素，但可以通过这两组数据可以求出flag。

  （这题刚出的时候是from data import q2，后来改文件给出q2，一直没发现文件改了直接卡死）

  ```python
  from libnum import *
  import gmpy2
  from rsa import transform
  p = 109935857933867829728985398563235455481120300859311421762540858762721955038310117609456763338082237907005937380873151279351831600225270995344096532750271070807051984097524900957809427861441436796934012393707770012556604479065826879107677002380580866325868240270494148512743861326447181476633546419262340100453
  q1q = 127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088835693
  q1p = 127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088834871
  e1 = 15218928658178
  e2 = 381791429275130
  q1=q1p
  q2 =  114401188227479584680884046151299704656920536168767132916589182357583461053336386996123783294932566567773695426689447410311969456458574731187512974868297092638677515283584994416382872450167046416573472658841627690987228528798356894803559278308702635288537653192098514966089168123710854679638671424978221959513
  
  c1 =  262739975753930281690942784321252339035906196846340713237510382364557685379543498765074448825799342194332681181129770046075018122033421983227887719610112028230603166527303021036386350781414447347150383783816869784006598225583375458609586450854602862569022571672049158809874763812834044257419199631217527367046624888837755311215081173386523806086783266198390289097231168172692326653657393522561741947951887577156666663584249108899327053951891486355179939770150550995812478327735917006194574412518819299303783243886962455399783601229227718787081785391010424030509937403600351414176138124705168002288620664809270046124
  c2 =  7395591129228876649030819616685821899204832684995757724924450812977470787822266387122334722132760470911599176362617225218345404468270014548817267727669872896838106451520392806497466576907063295603746660003188440170919490157250829308173310715318925771643105064882620746171266499859049038016902162599261409050907140823352990750298239508355767238575709803167676810456559665476121149766947851911064706646506705397091626648713684511780456955453552020460909638016134124590438425738826828694773960514221910109473941451471431637903182205738738109429736425025621308300895473186381826756650667842656050416299166317372707709596
  n1 = p*q1
  n2 = p*q2
  
  p=gcd(n1,n2)
  q1=n1/p
  q2=n2/p
  assert(p*q1==n1)
  assert(p*q2==n2)
  f1=(p-1)*(q1-1)
  f2=(p-1)*(q2-1)
  tmp=14
  
  e1=e1/tmp
  e2=e2/tmp
  bd1=invmod(e1,f1)
  bd2=invmod(e2,f2)
  
  m1=pow(c1,bd1,n1)
  m2=pow(c2,bd2,n2)
  m3=m1%p
  m2=m2%q2
  m1=m1%q1
  
  m=solve_crt([m1,m2,m3], [q1,q2,p]) 
  n=q1*q2
  f=(q1-1)*(q2-1)
  m=m%n
  d2=invmod(7,f)
  m=pow(m,d2,n)
  p = gmpy2.iroot(m, 2)[0]
  plaintext = transform.int2bytes(p)
  print(plaintext)
  ```

  