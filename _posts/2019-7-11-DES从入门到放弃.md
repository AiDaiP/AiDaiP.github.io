---
layout: post
title:  "DES从入门到放弃"
date:   2019-7-11
desc: ""
keywords: ""
categories: [Crypto]
tags: [Crypto,DES]
icon: icon-html
---

# DES从入门到放弃

* #### 基本操作

  ![7](https://raw.githubusercontent.com/AiDaiP/images/master/des/7.png)

* #### IP置换表

  ![2](https://raw.githubusercontent.com/AiDaiP/images/master/des/2.png)

  

  

* #### 扩展运算

  ![4](https://raw.githubusercontent.com/AiDaiP/images/master/des/4.png)

  方框内为32bit原始数据，扩展后为48bit

* #### S盒置换

  ![5](https://raw.githubusercontent.com/AiDaiP/images/master/des/5.png)

  ![8](https://raw.githubusercontent.com/AiDaiP/images/master/des/8.png)

  ![6](https://raw.githubusercontent.com/AiDaiP/images/master/des/6.png)

  输入6bit，第一位和第六位组成一个二进制数对应S盒中的行号，三四五位组成一个二进制数对应S盒中的列号，交叉点的数据是是该盒的输出

  * ##### S盒设计准则

    1. 每个S盒均为6位输入，4位输出。
    2.  没有一个S盒的输出位是接近输入位的线性函数。
    3. 如果将输入位的最左、最右端的位固定，变化中间的4位，每个可能的4位输出只得到一次.4）如果S盒的两个输入仅有1位的差异，则其输出必须至少有2位不同.5）如果S盒的两个输入仅有中间2位不同，则其输出必须至少有2位不同。
    4. 如果S盒的两个输入前2位不同，后两位已知，则其输出必不同。
    5. 对于输入之间的任何非零的6位差分，32对中至多有8对显示出的差分导致了相同的输出差分。

* #### P盒置换

  ![9](https://raw.githubusercontent.com/AiDaiP/images/master/des/9.png)

  把输入的每位映射到输出位

  输入0001 0000 1010 0001 0000 0000 0000 0001

  输出1000 0000 0000 0000 0000 1000 1000 0110

  * ##### P盒设计准则

    1. 在第i轮S盒的4位输出中，2位将影响S盒第i+1轮的中间位，其余2位将影响最后位。
    2. 每个S盒的4位输出影响6个不同的S盒，但没有一个影响同一个S盒。
    3. 如果一个S盒的4位输出影响另一个S盒的中间1位，那么后一个的输出位不会影响前一个S盒的中间1位。

* #### 子密钥生成

  ![10](https://raw.githubusercontent.com/AiDaiP/images/master/des/10.png)

  ![11](https://raw.githubusercontent.com/AiDaiP/images/master/des/11.png)

* #### 3DES

  使用三个密钥，执行三次DES算法

  加密过程：加密-解密-加密

  $C=Ek_3(Dk_2(Ek_1(P))) $

  解密过程：解密-加密-解密 

  $P=Dk_1(EK_2(Dk_3(C))) $

  

* #### DES弱密钥

  - ##### 产生原因

    DES加密与解密在算法上对称，区别只是密钥的使用顺序。将密文c输入，逆序使用子密钥就可以恢复明文

    若密钥生成的子密钥$k_1=k_{16},k_{15}=k_2,...k_9=k_8$，对一个明文加密两次，得到的还是明文，这样的密钥称为弱密钥

    64位的密钥K经PC-1之后，变为56位，分为高28位和低28位，分别进行移位。 

    若高28位和低28位为全0或全1，则经过移位后不变，16个子密钥都相同。

    移位是独立进行的，组合可以得到

    ```
    K1＝…＝K16＝0x000000000000
    K1＝…＝K16＝0xFFFFFFFFFFFF
    K1＝…＝K16＝0x000000FFFFFF
    K1＝…＝K16＝0xFFFFFF000000
    ```

    所以至少有四个弱密钥

    

    若两个密钥生成的子密钥恰好对称，由一个密钥加密的信息可以通过用另一个密钥再次加密来解密，这两个密钥称为一组半弱密钥

  - ##### 弱密钥

    $E_k(E_{k}(x))=x$

    ```
    0x0101010101010101
    0xFEFEFEFEFEFEFEFE
    0xE0E0E0E0F1F1F1F1
    0x1F1F1F1F0E0E0E0E
    若不考虑校验位以下四组也为弱密钥
    0x0000000000000000
    0xFFFFFFFFFFFFFFFF
    0xE1E1E1E1F0F0F0F0
    0x1E1E1E1E0F0F0F0F
    ```

  - ##### 半弱密钥

    $E_{k_1}(E_{k_2}(x))=x$

    ```
    0x011F011F010E010E 和 0x1F011F010E010E01
    0x01E001E001F101F1 和 0xE001E001F101F101
    0x01FE01FE01FE01FE 和 0xFE01FE01FE01FE01
    0x1FE01FE00EF10EF1 和 0xE01FE01FF10EF10E
    0x1FFE1FFE0EFE0EFE 和 0xFE1FFE1FFE0EFE0E
    0xE0FEE0FEF1FEF1FE 和 0xFEE0FEE0FEF1FEF1
    ```

    

