---
layout: post
title:  "DES从入门到放弃"
date:   2019-7-11
desc: ""
keywords: ""
categories: [Crypto]
tags: [Crypto,DES]
icon: icon-html
---

# DES从入门到放弃

* #### 基本操作

  ![7](https://raw.githubusercontent.com/AiDaiP/images/master/des/7.png)

* #### IP置换表

  ![2](https://raw.githubusercontent.com/AiDaiP/images/master/des/2.png)

  

  

* #### 扩展运算

  ![4](https://raw.githubusercontent.com/AiDaiP/images/master/des/4.png)

  方框内为32bit原始数据，扩展后为48bit

* #### S盒置换

  ![5](https://raw.githubusercontent.com/AiDaiP/images/master/des/5.png)

  ![8](https://raw.githubusercontent.com/AiDaiP/images/master/des/8.png)

  ![6](https://raw.githubusercontent.com/AiDaiP/images/master/des/6.png)

  输入6bit，第一位和第六位组成一个二进制数对应S盒中的行号，三四五位组成一个二进制数对应S盒中的列号，交叉点的数据是是该盒的输出

  对于上图S1盒，输入0b101011，输出0b1001

  * ##### S盒设计准则

    1. 每个S盒均为6位输入，4位输出。
    2.  没有一个S盒的输出位是接近输入位的线性函数。
    3. 如果将输入位的最左、最右端的位固定，变化中间的4位，每个可能的4位输出只得到一次.4）如果S盒的两个输入仅有1位的差异，则其输出必须至少有2位不同.5）如果S盒的两个输入仅有中间2位不同，则其输出必须至少有2位不同。
    4. 如果S盒的两个输入前2位不同，后两位已知，则其输出必不同。
    5. 对于输入之间的任何非零的6位差分，32对中至多有8对显示出的差分导致了相同的输出差分。

* #### P盒置换

  ![9](https://raw.githubusercontent.com/AiDaiP/images/master/des/9.png)

  把输入的每位映射到输出位

  输入0001 0000 1010 0001 0000 0000 0000 0001

  输出1000 0000 0000 0000 0000 1000 1000 0110

  * ##### P盒设计准则

    1. 在第i轮S盒的4位输出中，2位将影响S盒第i+1轮的中间位，其余2位将影响最后位。
    2. 每个S盒的4位输出影响6个不同的S盒，但没有一个影响同一个S盒。
    3. 如果一个S盒的4位输出影响另一个S盒的中间1位，那么后一个的输出位不会影响前一个S盒的中间1位。

* #### 子密钥生成

  ![10](https://raw.githubusercontent.com/AiDaiP/images/master/des/10.png)

  ![11](https://raw.githubusercontent.com/AiDaiP/images/master/des/11.png)

* #### 3DES

  使用三个密钥，执行三次DES算法

  加密过程：加密-解密-加密

  $C=Ek_3(Dk_2(Ek_1(P))) $

  解密过程：解密-加密-解密 

  $P=Dk_1(EK_2(Dk_3(C))) $

* #### 加密模式

  * #####  ECB

    电子密本方式，将数据按照8个字节一组分组进行DES加密或解密，之后按顺序连接

  * ##### CBC

    将数据按8个字节一组分组

    第一组数据与向量I异或后的结果进行DES加密得到第一组密文C1

    第二组数据与C1异或后的结果进行DES加密得到第二组密文C2

    以此类推，最后将密文按顺序连接

    * 加密：

      $ C_1 = Enc(Key, XOR(IV, P_1) $

      $C_i = Enc(Key, XOR(C_{i-1}, P_i) ​$

    * 解密

      $P_1 = XOR(IV, Dec(Key, C_1)) $

      $ P_i = XOR(C_{i-1}, Dec(Key,C_i)) $

    * 特点

      - 每次加密的密文长度为64位(8个字节)
      - 当相同的明文使用相同的密钥和初始向量的时候CBC模式总是产生相同的密文
      - 密文块要依赖以前的操作结果,所以，密文块不能进行重新排列
      - 可以使用不同的初始化向量来避免相同的明文产生相同的密文,一定程度上抵抗字典攻击
      - 一个错误发生以后,当前和以后的密文都会被影响

  * ##### CFB

    ![12](https://raw.githubusercontent.com/AiDaiP/images/master/des/12.png)

    * 加密

      $S_0 = IV$

      $O_i = Enc(Key, S_i)$

      $C_i = XOR( P_i, Lef(O_i))$

      $ S_i = A(S_{i-1}, C_i) $

    * 解密

      $S_0 = IV$

      $O_i = Enc(Key, S_i)$

      $P_i = XOR( C_i, Lef(O_i))$

      $ S_i = A(S_{i-1}, C_i)$

    $Lef(x)​$表示取x最左8位

    $A(x,y)$表示x左移8位，空位用y填充

    * 特点
      - 每次加密的Pi和Ci不大于64位
      - 加密算法和解密算法相同，不能适用于公钥算法
      - 使用相同的密钥和初始向量的时候，相同明文使用CFB模式加密输出相同的密文
      - 可以使用不同的初始化变量使相同的明文产生不同的密文，防止字典攻击
      - 加密强度依赖于密钥长度
      - 加密块长度过小时,会增加循环的数量,导致开销增加
      - 加密块长度应时8位的整数倍(即字节为单位)
      - 一旦某位数据出错,会影响目前和其后8个块的数据

  * ##### OFB

    ![13](https://raw.githubusercontent.com/AiDaiP/images/master/des/13.png)

    - 加密

      $S_0 = IV$

      $O_i = Enc(Key, S_i)$

      $C_i = XOR( P_i, Lef(O_i))​$

      $ S_i = A(S_{i-1}, O_i) $

    - 解密

      $S_0 = IV$

      $O_i = Enc(Key, S_i)$

      $P_i = XOR( C_i, Lef(O_i))$

      $ S_i = A(S_{i-1}, O_i)$

    - 特点

      - 因为密文没有参与链操作，所以使得OFB模式更容易受到攻击
      - 不会进行错误传播，某位密文发生错误，只会影响该位对应的明文，而不会影响别的位
      - 不是自同步的，如果加密和解密两个操作失去同步，那么系统需要重新初始化
      - 每次重新同步时，应使用不同的初始向量。可以避免产生相同的比特流，避免”已知明文”攻击 

      

* #### 填充

  * ##### ZeroPadding 

    数据长度不对齐时使用0填充，否则不填充。

  * ##### PKCS7Padding

    假设数据长度需要填充n(n>0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小。 

  * ##### PKCS5Padding 

    PKCS7Padding的子集，块大小固定为8字节。

    

* #### DES弱密钥

  - ##### 产生原因

    DES加密与解密在算法上对称，区别只是密钥的使用顺序。将密文c输入，逆序使用子密钥就可以恢复明文

    若密钥生成的子密钥$k_1=k_{16},k_{15}=k_2,...k_9=k_8$，对一个明文加密两次，得到的还是明文，这样的密钥称为弱密钥

    64位的密钥K经PC-1之后，变为56位，分为高28位和低28位，分别进行移位。 

    若高28位和低28位为全0或全1，则经过移位后不变，16个子密钥都相同。

    移位是独立进行的，组合可以得到

    ```
    K1＝…＝K16＝0x000000000000
    K1＝…＝K16＝0xFFFFFFFFFFFF
    K1＝…＝K16＝0x000000FFFFFF
    K1＝…＝K16＝0xFFFFFF000000
    ```

    所以至少有四个弱密钥

    

    若两个密钥生成的子密钥恰好对称，由一个密钥加密的信息可以通过用另一个密钥再次加密来解密，这两个密钥称为一组半弱密钥

  - ##### 弱密钥

    $E_k(E_{k}(x))=x$

    ```
    0x0101010101010101
    0xFEFEFEFEFEFEFEFE
    0xE0E0E0E0F1F1F1F1
    0x1F1F1F1F0E0E0E0E
    若不考虑校验位以下四组也为弱密钥
    0x0000000000000000
    0xFFFFFFFFFFFFFFFF
    0xE1E1E1E1F0F0F0F0
    0x1E1E1E1E0F0F0F0F
    ```

  - ##### 半弱密钥

    $E_{k_1}(E_{k_2}(x))=x$

    ```
    0x011F011F010E010E 和 0x1F011F010E010E01
    0x01E001E001F101F1 和 0xE001E001F101F101
    0x01FE01FE01FE01FE 和 0xFE01FE01FE01FE01
    0x1FE01FE00EF10EF1 和 0xE01FE01FF10EF10E
    0x1FFE1FFE0EFE0EFE 和 0xFE1FFE1FFE0EFE0E
    0xE0FEE0FEF1FEF1FE 和 0xFEE0FEE0FEF1FEF1
    ```

    

