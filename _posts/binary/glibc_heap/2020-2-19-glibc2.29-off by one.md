---
clayout: post
title:  "glibc2.29-off by one"
date:   2020-2-19
desc: ""
keywords: ""
categories: [Binary]
tags: [pwn]
icon: icon-html
---

#glibc2.29-off by one

## glibc2.29 unlink

```c
/* consolidate backward */
if (!prev_inuse(p)) {
  prevsize = prev_size (p);
  size += prevsize;
  p = chunk_at_offset(p, -((long) prevsize));
  if (__glibc_unlikely (chunksize(p) != prevsize))
    malloc_printerr ("corrupted size vs. prev_size while consolidating");
  unlink_chunk (av, p);
}
```
相比2.27，新增

```c
  if (__glibc_unlikely (chunksize(p) != prevsize))
    malloc_printerr ("corrupted size vs. prev_size while consolidating");
```

在2.27中，off by null有一种overlapping方法

1. malloc A B C，freeA，A进unsorted bin
2. 在B中伪造C的prev_size，off by null覆盖C的prev_inuse
3. free C，A、B、C unlink
4. malloc，把A、B、C取回来，之前的B并没有free，就得到了两个B

在第三步，根据C的prev_size找到A，然后直接unlink

在2.29中，新增了对size的检查，第三步，根据C的prev_size找到A，然后检查A的size和prev_size是否相等，不相等直接gg，如果👴想像2.27一样overlapping，👴还需要去伪造A的size

## 解决方案

### off by one

众所周知off by one比off by null白给，如果是off by one，👴就能在A前面的chunk中off by one改A的size

1. malloc X A B C，freeA，A进unsorted bin
2. 在X中off by one改Asize
3. 在B中伪造C的prev_size，off by one把C prev_inuse改成0
4. free C，A、B、C unlink
5. malloc，把A、B、C取回来，得到两个B

### off by null

伪造一个unsorted bin，再伪造prev_size，unlink时根据prev_size找到伪造的chunk，过check

伪造unsorted bin时fd和bk指向自己，fd->bk = bk->fd，这种方法需要堆地址白给

1. malloc A B C
2. 在A中伪造fake chunk，size和将要伪造的prev_size相同，fd和bk都指向自己
3. 在B中伪造C的prev_size，off by one把C prev_inuse改成0
4. free C，fake chunk、B、C unlink
5. malloc，把fake chunk、B、C 取回来，得到两个B

#### 0CTF2019 Final babyheap2.29



