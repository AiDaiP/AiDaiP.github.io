---
clayout: post
title:  "glibc2.29-tcache stashing unlink"
date:   2020-2-17
desc: ""
keywords: ""
categories: [Binary]
tags: [pwn]
icon: icon-html
---

# glibc2.29-tcache stashing unlink

> 👴的青春回来🌶

先学洋文

```
stashing	英[ˈstæʃɪŋ]    美[ˈstæʃɪŋ]
v.	存放; 贮藏; 隐藏;
[词典] stash的现在分词;
[例句] Instead of stashing an umbrella in your bag, consider grabbing one of his hats on a rainy day.
在下雨天，你不用在包里装把雨伞，而是可以考虑戴顶他的帽子。
[其他] 原型：stash
```



### 原理

```c
  /*
     If a small request, check regular bin.  Since these "smallbins"
     hold one size each, no searching within bins is necessary.
     (For a large request, we need to wait until unsorted chunks are
     processed to find best fit. But for small ones, fits are exact
     anyway, so we can check now, which is faster.)
   */

  if (in_smallbin_range (nb))
    {
      idx = smallbin_index (nb);
      bin = bin_at (av, idx);

      if ((victim = last (bin)) != bin)
        {
          bck = victim->bk;
	  if (__glibc_unlikely (bck->fd != victim))
	    malloc_printerr ("malloc(): smallbin double linked list corrupted");
          set_inuse_bit_at_offset (victim, nb);
          bin->bk = bck;
          bck->fd = bin;

          if (av != &main_arena)
	    set_non_main_arena (victim);
          check_malloced_chunk (av, victim, nb);
#if USE_TCACHE
	  /* While we're here, if we see other chunks of the same size,
	     stash them in the tcache.  */
	  size_t tc_idx = csize2tidx (nb);
	  if (tcache && tc_idx < mp_.tcache_bins)
	    {
	      mchunkptr tc_victim;

	      /* While bin not empty and tcache not full, copy chunks over.  */
	      while (tcache->counts[tc_idx] < mp_.tcache_count
		     && (tc_victim = last (bin)) != bin)
		{
		  if (tc_victim != 0)
		    {
		      bck = tc_victim->bk;
		      set_inuse_bit_at_offset (tc_victim, nb);
		      if (av != &main_arena)
			set_non_main_arena (tc_victim);
		      bin->bk = bck;
		      bck->fd = bin;

		      tcache_put (tc_victim, tc_idx);
	            }
		}
	    }
#endif
          void *p = chunk2mem (victim);
          alloc_perturb (p, bytes);
          return p;
        }
    }
```

申请了一个small chunk后，会去和申请大小一样smallbin找free chunk，如果有就把它放到tcache bin上

* 条件
  1. small bin上至少有两个free chunk
  2. tcache bin必须有空间

此时发生两种unlink

1. 把申请的small chunk从small bin中unlink出去，有完整性检查

   ```c
   	  if (__glibc_unlikely (bck->fd != victim))
   	    malloc_printerr ("malloc(): smallbin double linked list corrupted");
   ```

   

2. 把small bin中剩余的free chunk unlink到tcache bin中，没有检查

   ```c
   #if USE_TCACHE
   	  /* While we're here, if we see other chunks of the same size,
   	     stash them in the tcache.  */
   	  size_t tc_idx = csize2tidx (nb);
   	  if (tcache && tc_idx < mp_.tcache_bins)
   	    {
   	      mchunkptr tc_victim;
   
   	      /* While bin not empty and tcache not full, copy chunks over.  */
   	      while (tcache->counts[tc_idx] < mp_.tcache_count
   		     && (tc_victim = last (bin)) != bin)
   		{
   		  if (tc_victim != 0)
   		    {
   		      bck = tc_victim->bk;
   		      set_inuse_bit_at_offset (tc_victim, nb);
   		      if (av != &main_arena)
   			set_non_main_arena (tc_victim);
   		      bin->bk = bck;
   		      bck->fd = bin;
   
   		      tcache_put (tc_victim, tc_idx);
   	            }
   		}
   	    }
   #endif
   ```

   `bck->fd = bin;`可以利用

   bin是一个libc地址，如果能控制bck，就能任意地址写入一个libc地址，效果和unsorted bin attack差不多，👴的青春又回来🌶

   这个过程是一个循环，对于伪造的bck，bck->bk有可能是非法地址，下一个循环时会crash

   如果tcache bin只剩一个空间，循环一次结束，可以避免这种情况

   small bin可以通过last remainder得到

   1. 塞满tchache bin
   2. 再free一个进unsorted bin
   3. 从unsorted bin中切一部分出来，剩下last remainder的size在small范围 
   4. 申请比last remainder大的chunk，last remainder送进small bin

   