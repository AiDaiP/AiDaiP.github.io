---
clayout: post
title:  "glibc2.29-tcache stashing unlink"
date:   2020-2-17
desc: ""
keywords: ""
categories: [Binary]
tags: [pwn]
icon: icon-html
---

# glibc2.29-tcache stashing unlink

> ğŸ‘´çš„é’æ˜¥å›æ¥ğŸŒ¶

å…ˆå­¦æ´‹æ–‡

```
stashing	è‹±[ËˆstÃ¦ÊƒÉªÅ‹]    ç¾[ËˆstÃ¦ÊƒÉªÅ‹]
v.	å­˜æ”¾; è´®è—; éšè—;
[è¯å…¸] stashçš„ç°åœ¨åˆ†è¯;
[ä¾‹å¥] Instead of stashing an umbrella in your bag, consider grabbing one of his hats on a rainy day.
åœ¨ä¸‹é›¨å¤©ï¼Œä½ ä¸ç”¨åœ¨åŒ…é‡Œè£…æŠŠé›¨ä¼ï¼Œè€Œæ˜¯å¯ä»¥è€ƒè™‘æˆ´é¡¶ä»–çš„å¸½å­ã€‚
[å…¶ä»–] åŸå‹ï¼šstash
```



### åŸç†

```c
  /*
     If a small request, check regular bin.  Since these "smallbins"
     hold one size each, no searching within bins is necessary.
     (For a large request, we need to wait until unsorted chunks are
     processed to find best fit. But for small ones, fits are exact
     anyway, so we can check now, which is faster.)
   */

  if (in_smallbin_range (nb))
    {
      idx = smallbin_index (nb);
      bin = bin_at (av, idx);

      if ((victim = last (bin)) != bin)
        {
          bck = victim->bk;
	  if (__glibc_unlikely (bck->fd != victim))
	    malloc_printerr ("malloc(): smallbin double linked list corrupted");
          set_inuse_bit_at_offset (victim, nb);
          bin->bk = bck;
          bck->fd = bin;

          if (av != &main_arena)
	    set_non_main_arena (victim);
          check_malloced_chunk (av, victim, nb);
#if USE_TCACHE
	  /* While we're here, if we see other chunks of the same size,
	     stash them in the tcache.  */
	  size_t tc_idx = csize2tidx (nb);
	  if (tcache && tc_idx < mp_.tcache_bins)
	    {
	      mchunkptr tc_victim;

	      /* While bin not empty and tcache not full, copy chunks over.  */
	      while (tcache->counts[tc_idx] < mp_.tcache_count
		     && (tc_victim = last (bin)) != bin)
		{
		  if (tc_victim != 0)
		    {
		      bck = tc_victim->bk;
		      set_inuse_bit_at_offset (tc_victim, nb);
		      if (av != &main_arena)
			set_non_main_arena (tc_victim);
		      bin->bk = bck;
		      bck->fd = bin;

		      tcache_put (tc_victim, tc_idx);
	            }
		}
	    }
#endif
          void *p = chunk2mem (victim);
          alloc_perturb (p, bytes);
          return p;
        }
    }
```

ç”³è¯·äº†ä¸€ä¸ªsmall chunkåï¼Œä¼šå»å’Œç”³è¯·å¤§å°ä¸€æ ·smallbinæ‰¾free chunkï¼Œå¦‚æœæœ‰å°±æŠŠå®ƒæ”¾åˆ°tcache binä¸Š

* æ¡ä»¶
  1. small binä¸Šè‡³å°‘æœ‰ä¸¤ä¸ªfree chunk
  2. tcache binå¿…é¡»æœ‰ç©ºé—´

æ­¤æ—¶å‘ç”Ÿä¸¤ç§unlink

1. æŠŠç”³è¯·çš„small chunkä»small binä¸­unlinkå‡ºå»ï¼Œæœ‰å®Œæ•´æ€§æ£€æŸ¥

   ```c
   	  if (__glibc_unlikely (bck->fd != victim))
   	    malloc_printerr ("malloc(): smallbin double linked list corrupted");
   ```

   

2. æŠŠsmall binä¸­å‰©ä½™çš„free chunk unlinkåˆ°tcache binä¸­ï¼Œæ²¡æœ‰æ£€æŸ¥

   ```c
   #if USE_TCACHE
   	  /* While we're here, if we see other chunks of the same size,
   	     stash them in the tcache.  */
   	  size_t tc_idx = csize2tidx (nb);
   	  if (tcache && tc_idx < mp_.tcache_bins)
   	    {
   	      mchunkptr tc_victim;
   
   	      /* While bin not empty and tcache not full, copy chunks over.  */
   	      while (tcache->counts[tc_idx] < mp_.tcache_count
   		     && (tc_victim = last (bin)) != bin)
   		{
   		  if (tc_victim != 0)
   		    {
   		      bck = tc_victim->bk;
   		      set_inuse_bit_at_offset (tc_victim, nb);
   		      if (av != &main_arena)
   			set_non_main_arena (tc_victim);
   		      bin->bk = bck;
   		      bck->fd = bin;
   
   		      tcache_put (tc_victim, tc_idx);
   	            }
   		}
   	    }
   #endif
   ```

   `bck->fd = bin;`å¯ä»¥åˆ©ç”¨

   binæ˜¯ä¸€ä¸ªlibcåœ°å€ï¼Œå¦‚æœèƒ½æ§åˆ¶bckï¼Œå°±èƒ½ä»»æ„åœ°å€å†™å…¥ä¸€ä¸ªlibcåœ°å€ï¼Œæ•ˆæœå’Œunsorted bin attackå·®ä¸å¤šï¼ŒğŸ‘´çš„é’æ˜¥åˆå›æ¥ğŸŒ¶

   è¿™ä¸ªè¿‡ç¨‹æ˜¯ä¸€ä¸ªå¾ªç¯ï¼Œå¯¹äºä¼ªé€ çš„bckï¼Œbck->bkæœ‰å¯èƒ½æ˜¯éæ³•åœ°å€ï¼Œä¸‹ä¸€ä¸ªå¾ªç¯æ—¶ä¼šcrash

   å¦‚æœtcache binåªå‰©ä¸€ä¸ªç©ºé—´ï¼Œå¾ªç¯ä¸€æ¬¡ç»“æŸï¼Œå¯ä»¥é¿å…è¿™ç§æƒ…å†µ

   small binå¯ä»¥é€šè¿‡last remainderå¾—åˆ°

   1. å¡æ»¡tchache bin
   2. å†freeä¸€ä¸ªè¿›unsorted bin
   3. ä»unsorted binä¸­åˆ‡ä¸€éƒ¨åˆ†å‡ºæ¥ï¼Œå‰©ä¸‹last remainderçš„sizeåœ¨smallèŒƒå›´ 
   4. ç”³è¯·æ¯”last remainderå¤§çš„chunkï¼Œlast remainderé€è¿›small bin

   