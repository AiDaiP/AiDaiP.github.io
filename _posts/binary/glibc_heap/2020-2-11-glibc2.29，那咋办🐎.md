---
clayout: post
title:  "glibc2.29ï¼Œé‚£å’‹åŠğŸ"
date:   2020-2-11
desc: ""
keywords: ""
categories: [Binary]
tags: [pwn]
icon: icon-html
---

# glibc2.29ï¼Œé‚£å’‹åŠğŸ

tcache double free ä¸å¥½ä½¿äº†ï¼ŒğŸ‘´çš„é’æ˜¥ç»“æŸäº†

Unsortedbin Attack æ²¡äº†ï¼ŒğŸ‘´çš„é’æ˜¥ç»“æŸäº†

House of Force æ²¡äº†ï¼ŒğŸ‘´çš„é’æ˜¥ç»“æŸäº†

### æ–°å¢é˜²æŠ¤æœºåˆ¶

#### free

* tcache

  ```c
  #if USE_TCACHE
    {
      size_t tc_idx = csize2tidx (size);
      if (tcache != NULL && tc_idx < mp_.tcache_bins)
        {
  	/* Check to see if it's already in the tcache.  */
  	tcache_entry *e = (tcache_entry *) chunk2mem (p);
  
  	/* This test succeeds on double free.  However, we don't 100%
  	   trust it (it also matches random payload data at a 1 in
  	   2^<size_t> chance), so verify it's not an unlikely
  	   coincidence before aborting.  */
  	if (__glibc_unlikely (e->key == tcache))
  	  {
  	    tcache_entry *tmp;
  	    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
  	    for (tmp = tcache->entries[tc_idx];
  		 tmp;
  		 tmp = tmp->next)
  	      if (tmp == e)
  		malloc_printerr ("free(): double free detected in tcache 2");
  	    /* If we get here, it was a coincidence.  We've wasted a
  	       few cycles, but don't abort.  */
  	  }
  
  	if (tcache->counts[tc_idx] < mp_.tcache_count)
  	  {
  	    tcache_put (p, tc_idx);
  	    return;
  	  }
        }
    }
  #endif
  ```

  glibc2.29åœ¨tcache_entryç»“æ„ä½“ä¸­åŠ ä¸Šä¸€ä¸ª8å­—èŠ‚æŒ‡é’ˆkeyï¼Œä½ç½®å°±æ˜¯bkçš„ä½ç½®ï¼Œchunkè¿›å…¥tcacheåï¼Œå°†chunk->keyè®¾ç½®ä¸ºtcachestruct(heapå¼€å¤´+0x10)

  freeæ—¶ï¼Œè¿›tcacheå‰ä¼šæ£€æŸ¥chunk->keyæ˜¯å¦ä¸ºtcacheï¼Œå¦‚æœæ˜¯tcacheå°±ä¼šæ£€æŸ¥tcacheé“¾ä¸­æ˜¯å¦æœ‰ç›¸åŒçš„chunk

  æŠŠchunk->keyæ”¹äº†å°±å¯ä»¥ç»•è¿‡æ£€æŸ¥ï¼Œä½†æ˜¯ğŸ‘´å¯»æ€ğŸ‘´éƒ½èƒ½æ‘¸åˆ°bkäº†åº”è¯¥ä¹Ÿèƒ½æ‘¸åˆ°fdï¼Œé‚£ğŸ‘´åº”è¯¥ä¹Ÿâ‘§éœ€è¦double freeäº†

* unlink

  ```c
      /* consolidate backward */
      if (!prev_inuse(p)) {
        prevsize = prev_size (p);
        size += prevsize;
        p = chunk_at_offset(p, -((long) prevsize));
        if (__glibc_unlikely (chunksize(p) != prevsize))
          malloc_printerr ("corrupted size vs. prev_size while consolidating");
        unlink_chunk (av, p);
      }
  
  ```

  unlinkå‰åˆ¤æ–­prev_sizeå’Œè¦åˆå¹¶çš„chunk sizeæ˜¯å¦ç›¸åŒï¼ŒğŸ‘´overlappingè¿˜å¾—æ”¹size





#### malloc

* unsortedbin

  ```c
        while ((victim = unsorted_chunks (av)->bk) != unsorted_chunks (av))
          {
            bck = victim->bk;
            size = chunksize (victim);
            mchunkptr next = chunk_at_offset (victim, size);
  
            if (__glibc_unlikely (size <= 2 * SIZE_SZ)
                || __glibc_unlikely (size > av->system_mem))
              malloc_printerr ("malloc(): invalid size (unsorted)");
            if (__glibc_unlikely (chunksize_nomask (next) < 2 * SIZE_SZ)
                || __glibc_unlikely (chunksize_nomask (next) > av->system_mem))
              malloc_printerr ("malloc(): invalid next size (unsorted)");
            if (__glibc_unlikely ((prev_size (next) & ~(SIZE_BITS)) != size))
              malloc_printerr ("malloc(): mismatching next->prev_size (unsorted)");
            if (__glibc_unlikely (bck->fd != victim)
                || __glibc_unlikely (victim->fd != unsorted_chunks (av)))
              malloc_printerr ("malloc(): unsorted double linked list corrupted");
            if (__glibc_unlikely (prev_inuse (next)))
              malloc_printerr ("malloc(): invalid next->prev_inuse (unsorted)");
  ```

  wdnmd

  æ–°å¢å››é¡¹æ£€æŸ¥

  1. ä¸‹ä¸€ä¸ªchunkçš„size
  2. ä¸‹ä¸€ä¸ªchunkçš„prev_size
  3. unsorted binåŒå‘é“¾è¡¨çš„å®Œæ•´æ€§
  4. ä¸‹ä¸€ä¸ªchunkçš„prev_inuseä½
  5. éªŒäº†unsorted binåŒå‘é“¾è¡¨çš„å®Œæ•´æ€§Unsortedbin Attackç›´æ¥æ²¡äº†ï¼Œä¸Šé¦™

* large bin

  ```c
            else
              {
                victim_index = largebin_index (size);
                bck = bin_at (av, victim_index);
                fwd = bck->fd;
  
                /* maintain large bins in sorted order */
                if (fwd != bck)
                  {
                    /* Or with inuse bit to speed comparisons */
                    size |= PREV_INUSE;
                    /* if smaller than smallest, bypass loop below */
                    assert (chunk_main_arena (bck->bk));
                    if ((unsigned long) (size)
  		      < (unsigned long) chunksize_nomask (bck->bk))
                      {
                        fwd = bck;
                        bck = bck->bk;
  
                        victim->fd_nextsize = fwd->fd;
                        victim->bk_nextsize = fwd->fd->bk_nextsize;
                        fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim;
                      }
                    else
                      {
                        assert (chunk_main_arena (fwd));
                        while ((unsigned long) size < chunksize_nomask (fwd))
                          {
                            fwd = fwd->fd_nextsize;
  			  assert (chunk_main_arena (fwd));
                          }
  
                        if ((unsigned long) size
  			  == (unsigned long) chunksize_nomask (fwd))
                          /* Always insert in the second position.  */
                          fwd = fwd->fd;
                        else
                          {
                            victim->fd_nextsize = fwd;
                            victim->bk_nextsize = fwd->bk_nextsize;
                            fwd->bk_nextsize = victim;
                            victim->bk_nextsize->fd_nextsize = victim;
                          }
                        bck = fwd->bk;
                      }
                  }
                else
                  victim->fd_nextsize = victim->bk_nextsize = victim;
              }
  ```

  large bin attackè¿˜å¥½ä½¿

   large bin çš„ nextsize æˆç¯æ—¶æ²¡æœ‰æ£€æŸ¥ï¼ŒåŠ«æŒbk_nextsizeï¼Œå†™å…¥ä¸€ä¸ªå‡åœ°å€ï¼Œåœ¨æ’å…¥çš„æ—¶å€™ï¼Œä¼šæŠŠè¿™ä¸ªå‡åœ°å€å½“æˆä¸€ä¸ªçœŸçš„ chunk è¿›è¡ŒåŒå‘é“¾è¡¨æ’å…¥æ“ä½œï¼Œå°±ä¼šæŠŠè¦æ’å…¥çš„chunkåœ°å€å†™å…¥å‡åœ°å€

  ä¸¤ä¸ªchunkçš„sizeä¸èƒ½ç›¸åŒï¼Œå¦åˆ™ä¼šè¿›å…¥

  ```c
                        if ((unsigned long) size
  			  == (unsigned long) chunksize_nomask (fwd))
                          /* Always insert in the second position.  */
                          fwd = fwd->fd;
  ```

  large binçš„ fd_nextsize éœ€è¦è®¾ç½®ä¸º0ï¼Œå¦åˆ™ä¼šè¿›å…¥

  ```
            else
              {
                size = chunksize (victim);
  
                /*  We know the first chunk in this bin is big enough to use. */
                assert ((unsigned long) (size) >= (unsigned long) (nb));
  
                remainder_size = size - nb;
  
                /* unlink */
                unlink_chunk (av, victim);
  ```

  è¿‡ä¸äº†unlinkçš„æ£€æŸ¥

#### top chunk

```c
      victim = av->top;
      size = chunksize (victim);

      if (__glibc_unlikely (size > av->system_mem))
        malloc_printerr ("malloc(): corrupted top size");
```

ä½¿ç”¨top chunkæ—¶æ£€æŸ¥sizeå°äºsystem_mem(0x21000)

House of Forceä¸Šé¦™

