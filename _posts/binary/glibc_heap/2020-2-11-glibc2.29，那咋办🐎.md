---
clayout: post
title:  "glibc2.29ï¼Œé‚£å’‹åŠğŸ"
date:   2020-2-11
desc: ""
keywords: ""
categories: [Binary]
tags: [pwn]
icon: icon-html
---

# glibc2.29ï¼Œé‚£å’‹åŠğŸ

### æ–°å¢é˜²æŠ¤æœºåˆ¶

#### free

* ä¸ç™½ç»™çš„tcache

  ```c
  #if USE_TCACHE
    {
      size_t tc_idx = csize2tidx (size);
      if (tcache != NULL && tc_idx < mp_.tcache_bins)
        {
  	/* Check to see if it's already in the tcache.  */
  	tcache_entry *e = (tcache_entry *) chunk2mem (p);
  
  	/* This test succeeds on double free.  However, we don't 100%
  	   trust it (it also matches random payload data at a 1 in
  	   2^<size_t> chance), so verify it's not an unlikely
  	   coincidence before aborting.  */
  	if (__glibc_unlikely (e->key == tcache))
  	  {
  	    tcache_entry *tmp;
  	    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
  	    for (tmp = tcache->entries[tc_idx];
  		 tmp;
  		 tmp = tmp->next)
  	      if (tmp == e)
  		malloc_printerr ("free(): double free detected in tcache 2");
  	    /* If we get here, it was a coincidence.  We've wasted a
  	       few cycles, but don't abort.  */
  	  }
  
  	if (tcache->counts[tc_idx] < mp_.tcache_count)
  	  {
  	    tcache_put (p, tc_idx);
  	    return;
  	  }
        }
    }
  #endif
  ```

  glibc2.29åœ¨tcache_entryç»“æ„ä½“ä¸­åŠ ä¸Šä¸€ä¸ª8å­—èŠ‚æŒ‡é’ˆkeyï¼Œä½ç½®å°±æ˜¯bkçš„ä½ç½®ï¼Œchunkè¿›å…¥tcacheåï¼Œå°†chunk->keyè®¾ç½®ä¸ºtcachestruct(heapå¼€å¤´)

  freeæ—¶ï¼Œè¿›tcacheå‰ä¼šæ£€æŸ¥chunk->keyæ˜¯å¦ä¸ºtcacheï¼Œå¦‚æœæ˜¯tcacheå°±ä¼šæ£€æŸ¥tcacheé“¾ä¸­æ˜¯å¦æœ‰ç›¸åŒçš„chunk

  æŠŠchunk->keyæ”¹äº†å°±å¯ä»¥ç»•è¿‡æ£€æŸ¥ï¼Œä½†æ˜¯ğŸ‘´å¯»æ€ğŸ‘´éƒ½èƒ½æ‘¸åˆ°bkäº†åº”è¯¥ä¹Ÿèƒ½æ‘¸åˆ°fdï¼Œé‚£ğŸ‘´åº”è¯¥ä¹Ÿâ‘§éœ€è¦double freeäº†

* ä¸ç™½ç»™çš„unlink

  ```c
      /* consolidate backward */
      if (!prev_inuse(p)) {
        prevsize = prev_size (p);
        size += prevsize;
        p = chunk_at_offset(p, -((long) prevsize));
        if (__glibc_unlikely (chunksize(p) != prevsize))
          malloc_printerr ("corrupted size vs. prev_size while consolidating");
        unlink_chunk (av, p);
      }
  
  ```

  unlinkå‰åˆ¤æ–­prev_sizeå’Œè¦åˆå¹¶çš„chunk sizeæ˜¯å¦ç›¸åŒï¼ŒğŸ‘´overlappingè¿˜å¾—æ”¹size





#### malloc

* unsortedbin

  ```c
        while ((victim = unsorted_chunks (av)->bk) != unsorted_chunks (av))
          {
            bck = victim->bk;
            size = chunksize (victim);
            mchunkptr next = chunk_at_offset (victim, size);
  
            if (__glibc_unlikely (size <= 2 * SIZE_SZ)
                || __glibc_unlikely (size > av->system_mem))
              malloc_printerr ("malloc(): invalid size (unsorted)");
            if (__glibc_unlikely (chunksize_nomask (next) < 2 * SIZE_SZ)
                || __glibc_unlikely (chunksize_nomask (next) > av->system_mem))
              malloc_printerr ("malloc(): invalid next size (unsorted)");
            if (__glibc_unlikely ((prev_size (next) & ~(SIZE_BITS)) != size))
              malloc_printerr ("malloc(): mismatching next->prev_size (unsorted)");
            if (__glibc_unlikely (bck->fd != victim)
                || __glibc_unlikely (victim->fd != unsorted_chunks (av)))
              malloc_printerr ("malloc(): unsorted double linked list corrupted");
            if (__glibc_unlikely (prev_inuse (next)))
              malloc_printerr ("malloc(): invalid next->prev_inuse (unsorted)");
  ```

  wdnmd

  æ–°å¢å››é¡¹æ£€æŸ¥

  1. ä¸‹ä¸€ä¸ªchunkçš„size
  2. ä¸‹ä¸€ä¸ªchunkçš„prev_size
  3. unsorted binåŒå‘é“¾è¡¨çš„å®Œæ•´æ€§
  4. ä¸‹ä¸€ä¸ªchunkçš„prev_inuseä½

  éªŒäº†unsorted binåŒå‘é“¾è¡¨çš„å®Œæ•´æ€§Unsortedbin Attackç›´æ¥æ²¡äº†ï¼Œä¸Šé¦™

#### top chunk

```c
      victim = av->top;
      size = chunksize (victim);

      if (__glibc_unlikely (size > av->system_mem))
        malloc_printerr ("malloc(): corrupted top size");
```

ä½¿ç”¨top chunkæ—¶æ£€æŸ¥sizeå°äºsystem_mem(0x21000)

House of Forceä¸Šé¦™