---
clayout: post
title:  "angr从入门到放弃"
date:   2019-11-7
desc: ""
keywords: ""
categories: [Binary]
tags: [angr]
icon: icon-html
---

# angr从入门到放弃

## 基本操作

### defcamp_r100

![1](https://raw.githubusercontent.com/AiDaiP/images/master/angr/1.jpg)

sub_4006F0检查password

![2](https://raw.githubusercontent.com/AiDaiP/images/master/angr/2.jpg)

![4](https://raw.githubusercontent.com/AiDaiP/images/master/angr/4.jpg)

希望执行到0x400844，不希望执行0x400855

```python
p = angr.Project("r100")
simgr = p.factory.simulation_manager(p.factory.full_init_state())
simgr.explore(find=0x400844, avoid=0x400855)
print(simgr.found[0].posix.dumps(0))
#simgr.found[0].posix.dumps(0)代表该状态执行路径的所有输入
#simgr.found[0].posix.dumps(1)代表该状态执行路径的所有输出
```

![3](https://raw.githubusercontent.com/AiDaiP/images/master/angr/3.jpg)



## 从命令行获取参数

### ais3_crackme

![6](https://raw.githubusercontent.com/AiDaiP/images/master/angr/6.jpg)

verify

![5](https://raw.githubusercontent.com/AiDaiP/images/master/angr/5.jpg)

![7](https://raw.githubusercontent.com/AiDaiP/images/master/angr/7.jpg)

希望执行到0x400602，不希望执行0x40060e

使用claripy构造输入

claripy.BVS()创建位向量符号

claripy.BVV()创建位向量值

不能使用posix.dump(0)打印，使用found.solver.eval()获得符号执行结果

```python
import angr
import claripy
p = angr.Project("./ais3_crackme")
argv1 = claripy.BVS("argv1",100*8)
state = p.factory.entry_state(args=["./crackme1",argv1])
simgr = p.factory.simulation_manager(state)
simgr.explore(find=0x400602,avoid=0x40060E)
solution = simgr.found[0].solver.eval(argv1, cast_to=bytes)
print(solution)
```

![8](https://raw.githubusercontent.com/AiDaiP/images/master/angr/8.jpg)



## 设置约束条件

### csaw_wyvern

![9](https://raw.githubusercontent.com/AiDaiP/images/master/angr/9.jpg)

flag长度28，使用claripy构造28个变量，拼起来最后加上`\n`

```python
flag_chars = [claripy.BVS('flag_%d' % i, 8) for i in range(28)]
flag = claripy.Concat(*flag_chars + [claripy.BVV(b'\n')])
```

这是个C++程序，而angr只实现了C库，所以需要使用full_init_state方法和unicorn引擎

```
st = p.factory.full_init_state(
        args=['./wyvern'],
        add_options=angr.options.unicorn,
        stdin=flag,
)
```

设置条件约束，flag中没有\x00和\x0a

```python
for k in flag_chars:
    st.solver.add(k != 0)
    st.solver.add(k != 10)
```

```python
import angr
import claripy


p = angr.Project('wyvern')
flag_chars = [claripy.BVS('flag_%d' % i, 8) for i in range(28)]
flag = claripy.Concat(*flag_chars + [claripy.BVV(b'\n')])
st = p.factory.full_init_state(
        args=['./wyvern'],
        add_options=angr.options.unicorn,
        stdin=flag,
)

for k in flag_chars:
    st.solver.add(k != 0)
    st.solver.add(k != 10)


sm = p.factory.simulation_manager(st)
sm.explore(find=0x40E02C)
print(sm.found[0].posix.dumps(0))
```

![10](https://raw.githubusercontent.com/AiDaiP/images/master/angr/10.jpg)



## 对结果进行约束

### asisctffinals2015_fake

![11](https://raw.githubusercontent.com/AiDaiP/images/master/angr/11.jpg)

输入正确的值，输出flag

![13](https://raw.githubusercontent.com/AiDaiP/images/master/angr/13.jpg)

strtol将字符串转为整数，claripy构造的位向量符号无法转化，所以从0x4004AC开始，直接使rax为构造的位向量符号

```
state = p.factory.blank_state(addr=0x4004AC)
inp = state.solver.BVS('inp', 8*8)
state.regs.rax = inp
```

flag以ASIS{开头，}结尾

执行到0x400684时，flag在rdi中

对found状态下的rdi进行约束

```
flag_addr = found.regs.rdi
found.add_constraints(found.memory.load(flag_addr, 5) == int(binascii.hexlify(b"ASIS{"), 16))

flag = found.memory.load(flag_addr, 40)
for i in range(5, 5+32):
    cond_0 = flag.get_byte(i) >= ord('0')
    cond_1 = flag.get_byte(i) <= ord('9')
    cond_2 = flag.get_byte(i) >= ord('a')
    cond_3 = flag.get_byte(i) <= ord('f')
    cond_4 = found.solver.And(cond_0, cond_1)
    cond_5 = found.solver.And(cond_2, cond_3)
    found.add_constraints(found.solver.Or(cond_4, cond_5))
```

flag是v5,v6,v7,v8,v9，最多40字节，这个38我寻思能试出来

我一直在想怎么分析出来flag套着的是个16进制串，翻了一般这比赛其他的题，flag都是这格式

```python
import angr
import binascii

p = angr.Project("fake", auto_load_libs=False)

state = p.factory.blank_state(addr=0x4004AC)
inp = state.solver.BVS('inp', 8*8)
state.regs.rax = inp

simgr= p.factory.simulation_manager(state)
simgr.explore(find=0x400684)
found = simgr.found[0]

flag_addr = found.regs.rdi
found.add_constraints(found.memory.load(flag_addr, 5) == int(binascii.hexlify(b"ASIS{"), 16))

flag = found.memory.load(flag_addr, 40)
for i in range(5, 5+32):
    cond_0 = flag.get_byte(i) >= ord('0')
    cond_1 = flag.get_byte(i) <= ord('9')
    cond_2 = flag.get_byte(i) >= ord('a')
    cond_3 = flag.get_byte(i) <= ord('f')
    cond_4 = found.solver.And(cond_0, cond_1)
    cond_5 = found.solver.And(cond_2, cond_3)
    found.add_constraints(found.solver.Or(cond_4, cond_5))

found.add_constraints(flag.get_byte(32+5) == ord('}'))

flag_str = found.solver.eval(flag, cast_to=bytes)
#num = found.solver.eval(inp)
#pirnt(num)
print(flag_str)
```

![12](https://raw.githubusercontent.com/AiDaiP/images/master/angr/12.jpg)