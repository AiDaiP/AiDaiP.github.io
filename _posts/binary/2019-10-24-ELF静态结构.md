---
layout: post
title:  "ELF静态结构"
date:   2019-10-24
desc: ""
keywords: ""
categories: [Binary]
tags: [pwn]
icon: icon-html
---

# ELF静态结构

## ELF

ELF 是洋文`Executable and Linking Forma`的缩写，即可执行可连接格式，具有这种格式的文件成为ELF文件

在 ELF 规范中，所有符合 ELF 格式规范的都称为 ELF 文件，也称为目标文件

主要分为三种类型

1. **可重定位文件**

   用于与其它目标文件进行连接以构建可执行文件或动态链接库

   可重定位文件引用其他目标文件中的符号时，只给出一个名字而没有地址，需要在链接时进行重定位，所以称为可重定位文件

   例

   ```c
   //main.c
   int main(int argc, char const *argv[])
   {
   	fuc();
   	return 0;
   }
   ```

   ```c
   //func.c
   void fuc()
   {
   	puts("A1_D4i");
   }
   ```

   ```
   gcc -c main.c -o main.o
   gcc -c fuc.c -o fuc.o
   
   file main.o
   main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
   file fuc.o
   fuc.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
   ```

2. **共享目标文件**

   即动态连接库文件

   使用情况有两种

   * 在连接过程中与其它动态链接库或可重定位文件一起构建新的目标文件
   * 在可执行文件被加载的过程中，被动态链接到新的进程中，成为运行代码的一部分

   例

   ```
   file libc-2.27.so
   libc-2.27.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/l, BuildID[sha1]=b417c0ba7cc5cf06d1d1bed6652cedb9253c60d0, for GNU/Linux 3.2.0, stripped
   ```

   共享目标文件是可执行的

   ```
   ./libc-2.27.so
   GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1) stable release version 2.27.
   Copyright (C) 2018 Free Software Foundation, Inc.
   This is free software; see the source for copying conditions.
   There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
   PARTICULAR PURPOSE.
   Compiled by GNU CC version 7.3.0.
   libc ABIs: UNIQUE IFUNC
   For bug reporting instructions, please see:
   <https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs>
   ```

   

3. **可执行文件**

   经过链接的，可以执行的程序文件

   例
   
   ```
   gcc main.o fuc.o test
   file test
   test: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=6ec6ce6732da07955bd3a4aceabaa43e7f3f620b, not stripped
   ./test
   A1_D4i
   ```





```c
//hello.c
int	main(int argc, char const *argv[])
{
	puts("hello world");
	return 0;
}
```

```
gcc hello.c -o hello1
file hello1
hello1: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=fd4ebdec6f6339fcdd99a594cd6b62180fcc375c, not stripped
生成了ELF 64-bit LSB shared object而不是ELF 64-bit LSB executable

gcc hello.c -o hello2 -no-pie
file hello2
hello2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=5677faa90a57d5665abefef0a3a2137ee0c97b82, not stripped
关闭pie，生成了ELF 64-bit LSB executable
```







## ELF Header

```c
typedef struct
{
    unsigned char e_ident[EI_NIDENT];     /* 魔数和相关信息 */
    Elf32_Half    e_type;                 /* 目标文件类型 */
    Elf32_Half    e_machine;              /* 硬件体系 */
    Elf32_Word    e_version;              /* 目标文件版本 */
    Elf32_Addr    e_entry;                /* 程序进入点 */
    Elf32_Off     e_phoff;                /* 程序头部偏移量 */
    Elf32_Off     e_shoff;                /* 节头部偏移量 */
    Elf32_Word    e_flags;                /* 处理器特定标志 */
    Elf32_Half    e_ehsize;               /* ELF头部长度 */
    Elf32_Half    e_phentsize;            /* 程序头部中一个条目的长度 */
    Elf32_Half    e_phnum;                /* 程序头部条目个数  */
    Elf32_Half    e_shentsize;            /* 节头部中一个条目的长度 */
    Elf32_Half    e_shnum;                /* 节头部条目个数 */
    Elf32_Half    e_shstrndx;             /* 节头部字符表索引 */
} Elf32_Ehdr;
```

readelf -h查看ELF Header

```
readelf -h hello2
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x400400
  Start of program headers:          64 (bytes into file)
  Start of section headers:          6376 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         29
  Section header string table index: 28
```



* **e_ident[EI_NIDENT]**

  ```
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  ```

  16字节

  e_ident[0] - e_ident[3]为Magic number

  ```
  '\x7fELF'
  ```

   e_ident[4]是class，指明文件类型

  ```
  Class:                             ELF64
  ```

  ![1](D:\Ai\GitHub\images\elf\1.jpg)

   e_ident[5]是data，指明编码格式

  ```
  Data:                              2's complement, little endian
  ```

  ![2](D:\Ai\GitHub\images\elf\2.jpg)

   e_ident[6]是version，指明elf文件头的版本

  ```
  Version:                           1 (current)
  ```

  e_ident[7]-e_ident[14]为pad，通常为0

  

* **e_type**

  ELF文件类型

  ```
  Type:                              EXEC (Executable file)
  ```

  ![3](D:\Ai\GitHub\images\elf\3.jpg)

* **e_machine**

  指定适用的处理器体系结构

  ```
   Machine:                           Advanced Micro Devices X86-64
  ```

  ![4](D:\Ai\GitHub\images\elf\4.jpg)

* **e_version**

  指明目标文件的版本

  ```
  Version:                           0x1
  ```

  ![5](D:\Ai\GitHub\images\elf\5.jpg)

* **e_entry**

  指明程序入口的虚拟地址，即当文件被加载到进程空间里后，入口程序在进程地址空间里的地址

  ```
  Entry point address:               0x400400
  ```

* **e_phof**

  指明程序头表开始处在文件中的偏移量。如果没有程序头表，该值应设为0

  ```
  Start of program headers:          64 (bytes into file)
  ```

* **e_shoff**

  指明节头表开始处在文件中的偏移量。如果没有节头表，该值应设为0

  ```
  Start of section headers:          6376 (bytes into file)
  ```

* **e_flags**

  含有处理器特定的标志位。标志的名字符合”EF_machine_flag”的格式

  对于 Intel 架构的处理器来说，它没有定义任何标志位，所以 e_flags 应该为0

  ```
  Flags:                             0x0
  ```

* **e_ehsize**

  指明 ELF 文件头的大小，以字节为单位

  ```
  Size of this header:               64 (bytes)
  ```

* **e_phentsize**

  指明在程序头表中每一个表项的大小，以字节为单位

  ```
  Size of program headers:           56 (bytes)
  ```

* **e_phnum**

  指明程序头表中总共有多少个表项

  如果一个目标文件中没有程序头表，该值应设为0

  ```
  Number of program headers:         9
  ```

* **e_shentsize**
  指明在节头表中每一个表项的大小，以字节为单位

  ```
  Size of section headers:           64 (bytes)
  ```

* **e_shnum**
  指明节头表中总共有多少个表项

  如果一个目标文件中没有节头表，该值应设为0

  ```
  Number of section headers:         29
  ```

* **e_shstrndx**
  指明节头表中与节名字表相对应的表项的索引

  如果文件没有节名字表，此值应设置为SHN_UNDEF

  ```
  Section header string table index: 28
  ```



## 节

