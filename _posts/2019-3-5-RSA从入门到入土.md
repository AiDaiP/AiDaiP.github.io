---
layout: post
title:  "RSA从入门到入土"
date:   2019-3-5
desc: ""
keywords: ""
categories: [Crypto]
tags: [Crypto,RSA]
icon: icon-html
---

#  RSA从入门到入土

* #### 数学知识

  * ##### 互质

    如果两个或两个以上的整数的最大公约数是 1，则称它们为互质

    任意两个质数构成互质关系

  * ##### 同余

    给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，那么就称整数a与b对模m同余，记作$a≡b(mod\ m)$

  * ##### 模反元素

    如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。这时，b就叫做a对模数n的“模反元素” 。 

    即 $ab≡1 (mod\  n)$

  * ##### 扩展欧几里得算法

    扩展欧几里德算法是用来在已知a, b时，求解一组x，y，使它们满足贝祖等式 $ax+by = gcd(a, b)$

    

  * ##### 欧拉函数

    对正整数n，欧拉函数φ(n)是小于或等于n的正整数中与n互质的数的数目

    欧拉函数是积性函数，若m,n互质，则 $φ(mn)=φ(m)φ(n)$

    若n为质数，则 $φ(n)=n-1$

    

  * ##### 欧拉定理

    若n,a为正整数，且n,a互质，则 $a^{φ(n)}=1\ (mod\ n)$

    

* #### 密钥生成

  1. 随机选择两个不相等的质数p、q

     $p=14214677$

     $q=15733001$

     

  2. 计算p、q乘积n

     $n=p× q=223639527455677$

  3. 计算φ(n)

     $φ(n)=(p-1)(q-1)=14214676×15733000=‭223639497508000‬$

  4. 随机选择一个整数$e$  ($1<e<φ(n)$且e与φ(n) 互质)

     $e=30001$

  5. 计算e对于φ(n)的模反元素d

     $ed≡1\ (mod\ φ(n))$ 

     变形，得到一个二元一次方程

     $ed-kφ(n)=1$

     $30001d-‭223639497508000k=1$

     可以看作

     $30001x+223639497508000y=gcd(30001,223639497508000k)=1$

     使用扩展欧几里得算法求解，得到

     $(x,y)=(223639497508000,-30000)$

     $d=223639497508000$

  6. 将n和e封装成公钥，n和d封装成私钥

     公钥$(223639527455677,30001)$

     私钥$(223639527455677,223639497508000)$

     

     

* #### 加密与解密

  * 公钥加密

    $m^e≡c (mod\ n)$ 

    m为明文，c为密文，加密就是计算c

    加密“flag”

    m=0x666c6167=‭1718378855‬

    $‭1718378855^{30001} ≡c (mod\ 223639527455677)$

    解得$c=191215680523649$

    

  * 私钥解密

    $c^d≡m\ (mod\ n)$ 

    $191215680523649^{223639497508000}≡m\ (mod\ 223639527455677)$

    解得$m=‭1718378855$

    转化为字符串得到“flag”

    

    解密方法的证明

    证：$c^d≡m\ (mod\ n)$ 

    由加密规则可得

    $c=m^e-kn$

    代入，即证：

    $(m^e-kn)^d≡ m\ (mod\ n)$

    左边展开后除了第一项，其余项均模n余0，即证：

    $m^{ed}≡m\ (mod\ n)$ 

    d为e对于φ(n)的模反元素，所以

    $ed=hφ(n)+1$ 

    代入，即证：

    $m^{hφ(n)+1}≡m\ (mod\ n)$

    1. m、n互质

       根据欧拉定理可得

        $m^{φ(n)}=1\ (mod\ n)$

       所以

       $m(m^{φ(n)})^h=m\ (mod\ n)$

       即

       $m^{hφ(n)+1}≡m\ (mod\ n)$

       

    2. m、n不互质

       n的因数为1，n，p，q，若m、n不互质，必然有$m=kp$ 或 $m=kq$

       不妨设 $m=kp$

       $m<n$ 所以 $k<q$，k与q一定互质，kp和q互质，所以

       $(kp)^{φ(q)}≡1\ (mod\ q)​$

       即

       $(kp)^{q-1}≡1\ (mod\ q)$

       所以

       $[kp^{(q-1)}]^{h(p-1)}kp≡kp\ (mod\ q)​$

       即

       $(kp)^{ed}≡kp\ (mod\ q)$

       $(kp)^{ed}=tq+kp$

       $(kp)^{ed}$和$kp$能被p整除，所以t一定能被p整除

       设$t=ap$

       $(kp)^{ed}=apq+kp$

       即

       $m^{ed}=an+kp$

       所以

       $m^{ed}≡m\ (mod\ n)​$ 

       

* #### 快速幂取模

  * ##### 同余定理

    ```
    (a +/- b) % c = (a % c +/- b % c) % c 
    
    (a * b) % c = (a % c) * (b % c) % c 
    
    ab % c = (a % c)b % c
    ```

   * ##### 代码实现

     ```python
     def quick_mod(a,b,c):
         ans = 1
         t = a % c
         while b:
             if b & 1:
                 ans = (ans * t) % c
             t = (t * t) % c
             b >>= 1
         return ans
     ```

     

* #### 小公钥指数攻击

  * ##### 条件

    e特别小，如e = 3

  * ##### 原理

    $c≡m^{e}\ (mod\ n)​$ 

    $ m^{e} = c + kn ​$

    $ m = (c + kn)^{1/e} ​$

    枚举k，开e次根，直到开出整数

    **Jarvis-OJ-extremely-hard-rsa**

    

* #### Rabin算法

  * ##### 条件

    e = 2

  * ##### 原理

    $c=m^{2}\ mod\ n$ 

    $m_p =\sqrt{c}\ mod\ p $

    $m_q =\sqrt{c}\ mod\ q $

    

    若$p≡q≡3\ (mod\ 4)​$

    $m_p = c^{1/4(p+1)}\ mod\ p​$

    $m_q = c^{1/4(q+1)}\ mod\ q$

    $y_pp+y_qq=1$

    $gcdext(p,q)$解出$y_p,y_q$

    解出四个明文

    $a = (y_ppm_q+y_qq_mp)\ mod\ n​$

    $ b = n -a​$

    $c = (y_ppm_q-y_qq_mp)\ mod\ n$

    $d = n - c$

    **Jarvis-OJ-hard-rsa**

* #### 共模攻击

  * ##### 条件

    用相同的n不同的e对明文ｍ加密

  * ##### 原理

    $c_1 ≡ m^{e_1} (mod\ n)​$

    $c_2 ≡ m^{e_2} (mod\ n)​$

    $gcd(e_1,e_2) = 1$

    存在$s_1,s_2​$使$s_1e_1+s_2e_2 = 1​$

    $c_1≡m^{e_1}\ (mod\ n)​$ 

    $c_2≡m^{e_2}\ (mod\ n)​$ 

    所以

    $c_1^{s_1}c_2^{s_2}≡(m^{e_1})^{s_1}(m^{e_2})^{s_2}\ (mod\ n)​$ 

    $c_1^{s_1}c_2^{s_2}≡m^{e_1s_1+e_2s_2}\ (mod\ n)​$ 

    $c_1^{s_1}c_2^{s_2}≡m\ (mod\ n)$ 

    **Jarvis-OJ-very-hard-rsa**

* #### dp

  ```python
  import gmpy2
  e = 
  n = 
  dp = 
  for x in range(1, e):
      if(e*dp%x==1):
          p=(e*dp-1)//x+1
          if(n%p!=0):
              continue
          q=n//p
          phin=(p-1)*(q-1)
          d=gmpy.invert(e, phin)
  ```

* #### dp、dq

  ```python
  import gmpy2
  p = 
  q = 
  dp = 
  dq = 
  n = p*q
  phin = (p-1)*(q-1)
  dd = gmpy2.gcd(p-1, q-1)
  d=(dp-dq)//dd * gmpy2.invert((q-1)//dd, (p-1)//dd) * (q-1) +dq
  ```

  

* #### Wiener's attack

  * ##### 条件

    $d<1/3N^{1/4}$

  * ##### 原理

    [Wiener's attack](https://en.wikipedia.org/wiki/Wiener%27s_attack)

    [rsa-wiener-attack](https://github.com/pablocelayes/rsa-wiener-attack)

  

* #### Factoring with High Bits Known

  * ##### 条件

    已知N的一个因子的较高位

    ![coppersmith1](https://raw.githubusercontent.com/AiDaiP/images/master/rsa/coppersmith1.png)

    ```
    p.bit_length() == 1024 ,p的高位需已知约576位
    p.bit_length() == 512 ,p的高位需已知约288位
    ```

  * 例子

    ```python
    '''
    n = 110884890902749085253001083431222443088115610795940152564793628519927092107501946446399003764508722709710121804620193329162066855289179887539537634989483300155392790067446377224025966917227342075570751172611456818461296838516185655681858001119900898375522640670694604696426035782721144065487316221499661637517
    e = 65537
    c = 56d1b214082fd508567e0a4e101dcaa4f3edf262d7330cae4d75d94b874f53dfe3c9ba66d62a41b7e9331e67ae6907e3c028701e53555fea0832b2908471d04ceb98dbedf576a504902d50c3c32050fa036573de4f466f9c5de6b6bd4ad2f96bd6cd235a62c6c9555eb5ecf5b793b514f60d3e75a8307983c0f1aab746477a7b
    front = 754471047130831460574350468751127056146566410666010180184022324900851348720910487519
    backLength = 512 - front.bit_length()
    '''
    
    import binascii
    n=110884890902749085253001083431222443088115610795940152564793628519927092107501946446399003764508722709710121804620193329162066855289179887539537634989483300155392790067446377224025966917227342075570751172611456818461296838516185655681858001119900898375522640670694604696426035782721144065487316221499661637517
    cipher = 0x56c5afbc956157241f2d4ea90fd24ad58d788ca1fa2fddb9084197cfc526386d223f88be38ec2e1820c419cb3dad133c158d4b004ae0943b790f0719b40e58007ba730346943884ddc36467e876ca7a3afb0e5a10127d18e3080edc18f9fbe590457352dca398b61eff93eec745c0e49de20bba1dd77df6de86052ffff41247d
    e2 = 0x10001
    pbits = 512
    for i in range(0,4095):
      p4 = 0x636c1b2209b27268ad05ff5d64802c40d509cefccd92953227264dab0f27187dea4fdf000
      p4 = p4 + int(hex(i),16)
      kbits = pbits - p4.nbits() 
      p4 = p4 << kbits 
      PR.<x> = PolynomialRing(Zmod(n))
      f = x + p4
      roots = f.small_roots(X=2^kbits, beta=0.4) 
      if roots: 
        p = p4+int(roots[0])
        assert n % p == 0
        q = n/int(p)
        phin = (p-1)*(q-1)
        d = inverse_mod(e2,phin)
        print(d)
        cipher = 0x56d1b214082fd508567e0a4e101dcaa4f3edf262d7330cae4d75d94b874f53dfe3c9ba66d62a41b7e9331e67ae6907e3c028701e53555fea0832b2908471d04ceb98dbedf576a504902d50c3c32050fa036573de4f466f9c5de6b6bd4ad2f96bd6cd235a62c6c9555eb5ecf5b793b514f60d3e75a8307983c0f1aab746477a7b
        flag = pow(cipher,d,n)
        flag = hex(int(flag))[2:-1]
        print (binascii.unhexlify(flag))
    #https://sagecell.sagemath.org/
    ```

* #### Known High Bits Message Attack

  * ##### 例子

    ```python
    /*
    [+]n=0x7c3139d3be9a691abdf3ff49c712fcb84ba39bbd2189bb98d04e04d2d7cc086c9d31b06fdf828aaeeb3765e1ab8ea41a3f1b8c73b80a498f1e2eaad42a1ac7b8e54e705cd1e3e4a39940f9bdcd16d4b42ab71a826955cc78450d6915663c82ae80fd2f64b7e3a70f2b188b85a738759eeb0688dfa22525bbbe92d7934763445L
    [+]e=3
    [+]m=random.getrandbits(512)
    [+]c=pow(m,e,n)=0x20084d9c4fa81d903437a9fabea4a2ad025a00ddc961e4fcd0f52ff9ec750702c109ce0188ae96e540a5c3dcf55013ced9ee37ad9547240fc8773f81fbb509b0b8ab24ed0288a6e1f997b5c0b196236bc8da2df9cce77c559492963eeafbbe4f5a9cb18098bfac87a1e179b26f60948fb72327acc0675890009a04697b76073L
    [+]((m>>72)<<72)=0xb90f972f73ebb3952b3a8e50233f783732478d874795b44c33f685caf7637f4cd0c90cf3a599e1a01e84a28459220b31a490fd1892df58000000000000000000L
    */
    
    import time
    def matrix_overview(BB, bound):
        for ii in range(BB.dimensions()[0]):
            a = ('%02d ' % ii)
            for jj in range(BB.dimensions()[1]):
                a += '0' if BB[ii,jj] == 0 else 'X'
                a += ' '
            if BB[ii, ii] >= bound:
                a += '~'
            print a
    def coppersmith_howgrave_univariate(pol, modulus, beta, mm, tt, XX):
    
        dd = pol.degree()
        nn = dd * mm + tt
    
        if not 0 < beta <= 1:
            raise ValueError("beta should belongs in (0, 1]")
    
        if not pol.is_monic():
            raise ArithmeticError("Polynomial must be monic.")
       
        polZ = pol.change_ring(ZZ)
        x = polZ.parent().gen()
    
        # compute polynomials
        gg = []
        for ii in range(mm):
            for jj in range(dd):
                gg.append((x * XX)**jj * modulus**(mm - ii) * polZ(x * XX)**ii)
        for ii in range(tt):
            gg.append((x * XX)**ii * polZ(x * XX)**mm)
    
        BB = Matrix(ZZ, nn)
    
        for ii in range(nn):
            for jj in range(ii+1):
                BB[ii, jj] = gg[ii][jj]
    
        # display basis matrix
        if debug:
            matrix_overview(BB, modulus^mm)
    
        # LLL
        BB = BB.LLL()
    
        # transform shortest vector in polynomial    
        new_pol = 0
        for ii in range(nn):
            new_pol += x**ii * BB[0, ii] / XX**ii
    
        # factor polynomial
        potential_roots = new_pol.roots()
        print "potential roots:", potential_roots
    
        # test roots
        roots = []
        for root in potential_roots:
            if root[0].is_integer():
                result = polZ(ZZ(root[0]))
                if gcd(modulus, result) >= modulus^beta:
                    roots.append(ZZ(root[0]))
        return roots
    
    
    # RSA gen options (for the demo)
    length_N = 1024  # size of the modulus
    Kbits = 72      # size of the root
    e = 3
    N = 0x7c3139d3be9a691abdf3ff49c712fcb84ba39bbd2189bb98d04e04d2d7cc086c9d31b06fdf828aaeeb3765e1ab8ea41a3f1b8c73b80a498f1e2eaad42a1ac7b8e54e705cd1e3e4a39940f9bdcd16d4b42ab71a826955cc78450d6915663c82ae80fd2f64b7e3a70f2b188b85a738759eeb0688dfa22525bbbe92d7934763445L
    ZmodN = Zmod(N);
    
    C = 0x20084d9c4fa81d903437a9fabea4a2ad025a00ddc961e4fcd0f52ff9ec750702c109ce0188ae96e540a5c3dcf55013ced9ee37ad9547240fc8773f81fbb509b0b8ab24ed0288a6e1f997b5c0b196236bc8da2df9cce77c559492963eeafbbe4f5a9cb18098bfac87a1e179b26f60948fb72327acc0675890009a04697b76073L
    msg = 0xb90f972f73ebb3952b3a8e50233f783732478d874795b44c33f685caf7637f4cd0c90cf3a599e1a01e84a28459220b31a490fd1892df58000000000000000000
    P.<x> = PolynomialRing(ZmodN) #, implementation='NTL')
    pol = (msg + x)^e - C
    dd = pol.degree()
    
    # Tweak those
    beta = 1                                # b = N
    epsilon = beta / 7                      # <= beta / 7
    mm = ceil(beta**2 / (dd * epsilon))     # optimized value
    tt = floor(dd * mm * ((1/beta) - 1))    # optimized value
    XX = ceil(N**((beta**2/dd) - epsilon))  # optimized value
    
    # Coppersmith
    start_time = time.time()
    roots = coppersmith_howgrave_univariate(pol, N, beta, mm, tt, XX)
    
    # output
    print "\n# Solutions"
    print "we found:", str(roots)
    print("in: %s seconds " % (time.time() - start_time))
    print "\n"
    
    ```

  

* #### 部分私钥泄露

  * ##### 例子

    ```python
    /*
    [+]n=0x291b24eae63660849a91b7122663814918ae91d62e3431163c4f47ecdbf92c59c9c430bbcc9443e4ff3dedbe60b1c06f383771bf628cdd36e649aa0c96db4addac4885071b651d2b1ae4e131ae3c115f1a59b828999ca7af8f235b75ad5b757680249eaa9b531ec1edbf9204417f17df08ec550893ed36523fcfef7fb4b2415dL
    [+]e=3
    [+]m=random.getrandbits(512)
    [+]c=pow(m,e,n)=0x623dc16f9047da92278d94fe3cabbd89db4f8c4c612ac55a439df31e368133d697cb08a571e2aad2a194800a433bc00940967441bb7e0d30bfc0599c55aeefc4af8be67ffaac307b65a2096863ca87c6aad615535814758212baae7328ac1ae9bce9f39a52456852c4c0b9779edbb19016872f516e2be9fab463f3b405e25beL
    [+]d=invmod(e,(p-1)*(q-1))
    [+]d&((1<<512)-1)=0x91d03d35338acebcf703991efd4b3f9c88e2f022568c31a410a33062d3e3e24571dc3537e21741e6b1c9eba127db0a768842d79a3197dca5b86e2cd509cd3b93L
    */
    
    known_bits = 512
    e = 3
    X = var('X')
    N=0x291b24eae63660849a91b7122663814918ae91d62e3431163c4f47ecdbf92c59c9c430bbcc9443e4ff3dedbe60b1c06f383771bf628cdd36e649aa0c96db4addac4885071b651d2b1ae4e131ae3c115f1a59b828999ca7af8f235b75ad5b757680249eaa9b531ec1edbf9204417f17df08ec550893ed36523fcfef7fb4b2415d
    d0 = 0x91d03d35338acebcf703991efd4b3f9c88e2f022568c31a410a33062d3e3e24571dc3537e21741e6b1c9eba127db0a768842d79a3197dca5b86e2cd509cd3b93
    P.<x> = PolynomialRing(Zmod(N))
    for k in xrange(1, e+1):
        results = solve_mod([e * d0 * X - k * X * (N - X + 1) + k * N == X], 2 ** 512)
    
        for m in results:
            f = x * 2 ** known_bits + ZZ(m[0])
            f = f.monic()
            roots = f.small_roots(X = 1, beta=0.3)
    
            if roots:
                x0 = roots[0]
                p = gcd(2 ** known_bits * x0 + ZZ(m[0]), N)
                print '[+] Found factorization!'
                print 'p =', ZZ(p)
                print 'q =', N / ZZ(p)
                break
    n=0x291b24eae63660849a91b7122663814918ae91d62e3431163c4f47ecdbf92c59c9c430bbcc9443e4ff3dedbe60b1c06f383771bf628cdd36e649aa0c96db4addac4885071b651d2b1ae4e131ae3c115f1a59b828999ca7af8f235b75ad5b757680249eaa9b531ec1edbf9204417f17df08ec550893ed36523fcfef7fb4b2415d
    p = 4369408607185874842987791687972458181281635894126489505104950532427588844072160412371716367300194382551703650763840526184308340422066926730909955032516327
    q = 6606303039610996668393006981258443682930645126368365403476569537191826726070101133886617447839914797821331788273937106747740172175833966059802001454391579
    e = 3
    phin = (p-1)*(q-1)
    d = inverse_mod(e,phin)
    cipher = 0x623dc16f9047da92278d94fe3cabbd89db4f8c4c612ac55a439df31e368133d697cb08a571e2aad2a194800a433bc00940967441bb7e0d30bfc0599c55aeefc4af8be67ffaac307b65a2096863ca87c6aad615535814758212baae7328ac1ae9bce9f39a52456852c4c0b9779edbb19016872f516e2be9fab463f3b405e25be
    print(d)
    flag = pow(cipher,d,n)
    flag = hex(int(flag))[2:-1]
    print(flag)
    
    ```

  

* #### Broadcast Attack

  * ##### 中国剩余定理

    ![中国剩余定理](https://raw.githubusercontent.com/AiDaiP/images/master/rsa/中国剩余定理.png)

  * ##### 例子

    ```python
    /*
    [+]e=3
    [+]m=random.getrandbits(512)
    [+]n1=0x20833e893b24b5240f940bfddd7ee7e4877c6c09858f74e6b9a30e2f6b4ddcc79f4aeb74818a210481bc0cede15edf5a78f3e976690fe2471ef27e3a176d5cbf01a378be85f3ad560fa0992355c636144f5157cc196a027d87e250315f83346a19b735ec151895f42c6300a87d8345c3e98d2489fae8e6a63f5f776af8e32547L
    [+]c1=pow(m,e,n1)=0x19da41d645595b0d29f9b73001e6aff709d638965bfd979bce43199d7ac8c48551ff5d833ad02fb75e4d5c9cb54ee3426d8aee37b74997d546b2fc7a98f290fc24de72cb6ac037fb2ba6d6e648e4557cfcae97ac2e38b66565a46802ca93b9b2f51486b9b20199fe92094e49372032432c38afc1290da70c06424f6d2d90d25fL
    [+]n2=0x15a07bcc2a00701d9e3900df672c562335d402cbba28f2e5d2daf8652db264e6812370e89d94f4e99c1402c7c897d52d9c55cdcc2d5da6f5a27f76c418ec907ed269a17a2d771b5ef54f9b44ed2406a7bb5a0aa5a104777b62f76d763b545c324f13cb33e656529edcc23be550af58ca905f777991d41f1521b3f8ffdad9370fL
    [+]c2=pow(m,e,n2)=0x70ec72eb18272633ee5e92baa8276bf8609ffb3645a0be15b0d0143ae04a3d2861f69e8329f59628d1836eaeebc6cb4ac26dc373c7de240ccc8d069448f6cadabfe7134cd495fa278cfcdda89aaf137e306621f92bc78feeb687ec1dced4856c4fc6cdc77b5db239dbd1f4d677137546a0d8ca532093f171c2f7da1278eeba9L
    [+]n3=0x1a70d5223cc981967a5d3f29072804804eb3c49a7375854ff63b438485cbc2740a94d52c5079eed1fccb4d05689c8cec6a2fe1559e5106cebe080621aa953848aae939308c5f06d3cd5b9699c29abaf350605efdd62f2fd324456b7f6c42fd59e069ead9040de68717444415999fe8e0ce2e23fc733988704e3179f621587c63L
    [+]c3=pow(m,e,n3)=0x105ee63d6a1db25bf85c419f827c2f4bc7d460033b10fd8a3d63ecdb8bcc82dcc84a500b94ab4b4aff7ba1db514cfcec5c70a06980d9fe7be6a4a74d7dcee16c5bb40f2ba32d5f3bf889bf1eb563018c066466b47883d90f8da684f1bb030f8834f6dd9e70b055d7a090696112e9f38f7d90cf4eb037a27e7247eeee4b55cd97L
    */
    
    import gmpy2
    dic = [{"c": 0x105ee63d6a1db25bf85c419f827c2f4bc7d460033b10fd8a3d63ecdb8bcc82dcc84a500b94ab4b4aff7ba1db514cfcec5c70a06980d9fe7be6a4a74d7dcee16c5bb40f2ba32d5f3bf889bf1eb563018c066466b47883d90f8da684f1bb030f8834f6dd9e70b055d7a090696112e9f38f7d90cf4eb037a27e7247eeee4b55cd97, "e": 3, "n": 0x1a70d5223cc981967a5d3f29072804804eb3c49a7375854ff63b438485cbc2740a94d52c5079eed1fccb4d05689c8cec6a2fe1559e5106cebe080621aa953848aae939308c5f06d3cd5b9699c29abaf350605efdd62f2fd324456b7f6c42fd59e069ead9040de68717444415999fe8e0ce2e23fc733988704e3179f621587c63},
    {"c": 0x70ec72eb18272633ee5e92baa8276bf8609ffb3645a0be15b0d0143ae04a3d2861f69e8329f59628d1836eaeebc6cb4ac26dc373c7de240ccc8d069448f6cadabfe7134cd495fa278cfcdda89aaf137e306621f92bc78feeb687ec1dced4856c4fc6cdc77b5db239dbd1f4d677137546a0d8ca532093f171c2f7da1278eeba9, "e": 3, "n": 0x15a07bcc2a00701d9e3900df672c562335d402cbba28f2e5d2daf8652db264e6812370e89d94f4e99c1402c7c897d52d9c55cdcc2d5da6f5a27f76c418ec907ed269a17a2d771b5ef54f9b44ed2406a7bb5a0aa5a104777b62f76d763b545c324f13cb33e656529edcc23be550af58ca905f777991d41f1521b3f8ffdad9370f},
    {"c": 0x19da41d645595b0d29f9b73001e6aff709d638965bfd979bce43199d7ac8c48551ff5d833ad02fb75e4d5c9cb54ee3426d8aee37b74997d546b2fc7a98f290fc24de72cb6ac037fb2ba6d6e648e4557cfcae97ac2e38b66565a46802ca93b9b2f51486b9b20199fe92094e49372032432c38afc1290da70c06424f6d2d90d25f, "e": 3, "n": 0x20833e893b24b5240f940bfddd7ee7e4877c6c09858f74e6b9a30e2f6b4ddcc79f4aeb74818a210481bc0cede15edf5a78f3e976690fe2471ef27e3a176d5cbf01a378be85f3ad560fa0992355c636144f5157cc196a027d87e250315f83346a19b735ec151895f42c6300a87d8345c3e98d2489fae8e6a63f5f776af8e32547}]
    n = []
    C = []
    for i in dic:
        n.append(i["n"])
        C.append(i["c"])
    
    N = 1
    for i in n:
        N *= i
    
    Ni = []
    for i in n:
        Ni.append(N / i)
    
    T = []
    for i in xrange(3):
        T.append(long(gmpy2.invert(Ni[i], n[i])))
    
    X = 0
    for i in xrange(3):
        X += C[i] * Ni[i] * T[i]
    
    m3 = X % N
    m = gmpy2.iroot(m3, 3)
    print(m)
    
    ```

* #### Broadcast Attack with Linear Padding 

  * ##### 原理

    $ c_1={(a_1*m+b_1)}^3modn_1$

    $ c_2={(a_2*m+b_2)}^3modn_2$

    $ c_3={(a_3*m+b_3)}^3modn_3$

    $T_1modn_1=1$

    $T_1modn_2=0$

    $T_1modn_3=0$

    $T_2modn_1=0$

    $T_2modn_2=1$

    $T_2modn_3=0$

    $T_3modn_1=0$

    $T_3modn_2=0$

    $T_3modn_3=1$

    $[T_1*(a_1*m+b_1)^3-c_1]modn_1n_2n_3=0$

    $[T_2*(a_2*m+b_2)^3-c_2]modn_1n_2n_3=0$

    $[T_3*(a_3*m+b_3)^3-c_3]modn_1n_2n_3=0​$

  * ##### 例子

    ```python
    cArray=[0x3ec0dac47c45bcb89edda91a302ee32b7202a93fac6056176cd6bd8f7a94b5f2c43fa10c5e4dae5e2bef32f13141889ea7ac09bae39966821e1c3b516eb7ddc41de8d9db2fed5f012614a1ee4fc8515fb18cfed81834be3f869dfb6d38279a1f670ccfa56ef1f1377651e11c2e9dd917701f1eac41653138e1777006d41b3f6b,
    0x2a50058d6bac5ecc1d20e60e6dd3b74b372e761b49be0826f2c803fe7dff502b64202905fad1f336650313825b1e3d5e5bfb739f135e3bc69052394a20d1cfe6498d9e78730b3cab49b78e64b6388d0e7cb3a4ad9458ec4cc6415bc509af080d20dc6f95056f7619c525bc482389afea0e8c5693b6e46f06e28dac8867ee987a,
    0x20ac4dd17cfd459112dbd86d024a4a44d841bf7eaec3167cc0a430bf6854c6552dde5aad514fdff23fa9ee9f416000450b772406e9ba545076787ce6e9dedf38d70601dcdc3a7cc46fa60c1877ec680081dd324de5235d40526c55d0f975f65e4e6734871e0338503b7256f7e9ad16cbe4d1329675d7fd7c97778a5c32ca1127]
     
    nArray=[0x8de0792c98a93c950ea12c65d62fdbbfd46d6aab145bc39ecebb371acd6774ee9fba24db94437485b5938249bdedf32d2aa2e8799b6aa6db63bbb2ddd5b458f1f437769a7710eee95069b3650e96253e4b0c5e2a22389673f74b0b01bd0956669a519aec556383f9b8d76f04b2a00a491625649bc6af4a1fa4e10aefc8c33cb5,
    0x948279bc2d86bee933357246711e64b5dff9f924e97559d0527aaa265e441a5ca259538161d5fe3efcbdc85b72b46b96d50afa3bf5d4bab7b850bcfa604fa74ef525b710e11d7f2c26b6df595cb9ea2b9a81fc81f0a721fbd9b0fef341bd471457c64efad02df1a2e93ada374627f55c33a178890904adb982e3d5df4fe78433,
    0xa98e47d25554632b5c2a2b6d292f2caf088050eb1ffbc556c062bebdb10f65fcbb942b9f0fdafa724ca90ea85ab17c1c2cd15eb4a59bf672909fbf0ef0fb88ac2569e571741162805c495b60dd8ea0eee9e5afb2ddcd5435d5fcfbd1c49f496eaef37ecde17b6a64a69cb869425d77d13f487632504b851f309ff36c826570cb]
    aArray=[0x8f2b591edb38649f6637abc8cd63f2e9f50e024d7230151b1f888190a821d10213587f34633dd2a7b40f4d37c338c420acdc2df19f88e958a250cd691922c781,
    0xae3e922d88e35e986e5dd4e8dedab00a1ab7f9f5f3fd658eade9371d1247ef7ada800ca381ff3f9c69a30dbf3c61c9f9539863fdb2d2c8af23d4cb87a9e5857f,
    0xe4550619a6029ac6158f188a969741cdd2cc37d1ff2c9dd1f24a7f6b12357196a15852912cb61e64e4ccb2ff6dae5a5f654fbe20623f04c6d8428d72ad5e02ef]
    bArray=[0xc955b34abfce3a409449bebc24163397795a163d337b7fb1320900aaffc21576d785b115f7d3dca7ada072f1c6608dfeb49c6c6264e5f691cf9bb96548222581,
    0xcb50868d5d12d5f166b2e57ef4789f8ebaacc1137a055118d1650e4557bcf05f3858a9124783c8be9be947667b45cdf1a4e2604e544210e8acc665e1c1c0d2ef,
    0x97a4d4c4b3e5ed99a5539ac17cde2a32890a0601be7f7bb6026cfe4a9ffe93633be15c4345268fec2bc69030353db729ccacfeaa3aa0952df418220db0266b4f]
     
    """
    Performs Hastads attack on raw RSA with no padding.
    cArray = Ciphertext Array
    nArray = Modulus Array
    e = public exponent
    """
    def hastads(cArray,nArray,e=3):
    	if(len(cArray)==len(nArray)==e):
    		for i in range(e):
    			cArray[i] = Integer(cArray[i])
    			nArray[i] = Integer(nArray[i])
    		M = crt(cArray,nArray)
    		return(Integer(M).nth_root(e,truncate_mode=1))
    	else:
    		print("CiphertextArray, ModulusArray, need to be of the same length, and the same size as the public exponent")
     
     
    """
    Performs Hastads attack on raw RSA with no padding.
    This is for RSA encryptions of the form: cArray[i] = pow(aArray[i]*msg + bArray[i],e,nArray[i])
    Where they are all encryptions of the same message.
    cArray = Ciphertext Array
    nArray = Modulus Array
    aArray = Array of 'slopes' for the linear padding
    bArray = Array of 'y-intercepts' for the linear padding
    e = public exponent
    """
    def linearPaddingHastads(cArray,nArray,aArray,bArray,e=3,eps=1/8):
    	if(len(cArray) == len(nArray) == len(aArray) == len(bArray) == e):
    		for i in range(e):
    			cArray[i] = Integer(cArray[i])
    			nArray[i] = Integer(nArray[i])
    			aArray[i] = Integer(aArray[i])
    			bArray[i] = Integer(bArray[i])
    		TArray = [-1]*e
    		for i in range(e):
    			arrayToCRT = [0]*e
    			arrayToCRT[i] = 1
    			print arrayToCRT
    			TArray[i] = crt(arrayToCRT,nArray)
    		print TArray
    		P.<x> = PolynomialRing(Zmod(prod(nArray)))
    		gArray = [-1]*e
    		for i in range(e):
    			gArray[i] = TArray[i]*(pow(aArray[i]*x + bArray[i],e) - cArray[i])
    		print gArray
    		g = sum(gArray)
    		g = g.monic()
    		# Use Sage's inbuilt coppersmith method
    		roots = g.small_roots(epsilon=eps)
    		if(len(roots)== 0):
    			print("No Solutions found")
    			return -1
    		return roots[0]
    	else:
    		print("CiphertextArray, ModulusArray, and the linear padding arrays need to be of the same length," + "and the same size as the public exponent")
     
    print(hastads(cArray,nArray))
    print(linearPaddingHastads(cArray,nArray,aArray,bArray))
    ```

    

* #### Coppersmith’s short-pad attack

  * ##### 例子

    ```python
    [+]n=0xc9f2c02d0ce22b192b5a046f8311b3eb470394ef228bbe8bc31f2939e3d7472a62eea2468c06b7d7de3a155a2e5a10c98143ede2fdf2f60fe5d65c9ba9fa26f5f7d05591201c76765599fb35f13e00a5b089fd4215c57b1453aaefc911a73c9f39003153af5e4a2e882a1c6c02d0024a6b0dede6c159a65b0bfe5c57b616127L
    [+]e=3
    [+]m=random.getrandbits(512)
    [+]c=pow(m,e,n)=0xb6046b56183fcc80d8a7c5dbc1f39176e736e2054255002abe1947a6e51fb7c37bdd689235613aec0e2a2651fade4837b968d4d6396b908a407f35e742065a773499f3bcd6111f2a1d8b65a3c79c9d3b20d681b9bf8cb2f26d2c528bca82e76d45ec734647cb13ca1a327e88173a64839bd4d8e576427600c86e7bc7224832cL
    [+]x=pow(m+1,e,n)=0xb590cc6da005f5bae916d26dca52f3f8e4c6c77d3d24df9f1f6e4e1ef1e58dc3b2bb0571810f5f27b019be2a768a392057c83006cbb12363b9661089d3fae650017c64d218ebe2b48b2ae91128d7613e6e51fabb94e7aaaba01d711d40ddac122683060ca5416ff0a00fa7f043f834d3989f8240b677a0cdda107832abe56c4L
    
    import gmpy2
    def getM2(a,b,c1,c2,n):
        a3 = pow(a,3,n)
        b3 = pow(b,3,n)
        first = c1-a3*c2+2*b3
        first = first % n
        second = 3*b*(a3*c2-b3)
        second = second % n
        third = second*gmpy2.invert(first,n)
        third = third % n
        fourth = (third+b)*gmpy2.invert(a,n)
        return fourth % n
    n=0xc9f2c02d0ce22b192b5a046f8311b3eb470394ef228bbe8bc31f2939e3d7472a62eea2468c06b7d7de3a155a2e5a10c98143ede2fdf2f60fe5d65c9ba9fa26f5f7d05591201c76765599fb35f13e00a5b089fd4215c57b1453aaefc911a73c9f39003153af5e4a2e882a1c6c02d0024a6b0dede6c159a65b0bfe5c57b616127L
    e=3
    c1=0xb6046b56183fcc80d8a7c5dbc1f39176e736e2054255002abe1947a6e51fb7c37bdd689235613aec0e2a2651fade4837b968d4d6396b908a407f35e742065a773499f3bcd6111f2a1d8b65a3c79c9d3b20d681b9bf8cb2f26d2c528bca82e76d45ec734647cb13ca1a327e88173a64839bd4d8e576427600c86e7bc7224832cL
    c2=0xb590cc6da005f5bae916d26dca52f3f8e4c6c77d3d24df9f1f6e4e1ef1e58dc3b2bb0571810f5f27b019be2a768a392057c83006cbb12363b9661089d3fae650017c64d218ebe2b48b2ae91128d7613e6e51fabb94e7aaaba01d711d40ddac122683060ca5416ff0a00fa7f043f834d3989f8240b677a0cdda107832abe56c4L
    padding1 = 0
    padding2 = 1
    m = getM2(1,padding1-padding2,c1,c2,n)-padding2
    print(hex(m))
    
    ```

  

* #### Boneh and Durfee attack

  * ##### 例子

    ```python
    /*
    [+]n=0xbadd260d14ea665b62e7d2e634f20a6382ac369cd44017305b69cf3a2694667ee651acded7085e0757d169b090f29f3f86fec255746674ffa8a6a3e1c9e1861003eb39f82cf74d84cc18e345f60865f998b33fc182a1a4ffa71f5ae48a1b5cb4c5f154b0997dc9b001e441815ce59c6c825f064fdca678858758dc2cebbc4d27L
    [+]d=random.getrandbits(1024*0.270)
    [+]e=invmod(d,phin)
    [+]hex(e)=0x11722b54dd6f3ad9ce81da6f6ecb0acaf2cbc3885841d08b32abc0672d1a7293f9856db8f9407dc05f6f373a2d9246752a7cc7b1b6923f1827adfaeefc811e6e5989cce9f00897cfc1fc57987cce4862b5343bc8e91ddf2bd9e23aea9316a69f28f407cfe324d546a7dde13eb0bd052f694aefe8ec0f5298800277dbab4a33bbL
    [+]m=random.getrandbits(512)
    [+]c=pow(m,e,n)=0xe3505f41ec936cf6bd8ae344bfec85746dc7d87a5943b3a7136482dd7b980f68f52c887585d1c7ca099310c4da2f70d4d5345d3641428797030177da6cc0d41e7b28d0abce694157c611697df8d0add3d900c00f778ac3428f341f47ecc4d868c6c5de0724b0c3403296d84f26736aa66f7905d498fa1862ca59e97f8f866cL
    */
    
    import time
    
    strict = False
    
    helpful_only = True
    dimension_min = 7 # stop removing if lattice reaches that dimension
    
    def helpful_vectors(BB, modulus):
        nothelpful = 0
        for ii in range(BB.dimensions()[0]):
            if BB[ii,ii] >= modulus:
                nothelpful += 1
    
        print nothelpful, "/", BB.dimensions()[0], " vectors are not helpful"
    
    # display matrix picture with 0 and X
    def matrix_overview(BB, bound):
        for ii in range(BB.dimensions()[0]):
            a = ('%02d ' % ii)
            for jj in range(BB.dimensions()[1]):
                a += '0' if BB[ii,jj] == 0 else 'X'
                if BB.dimensions()[0] < 60:
                    a += ' '
            if BB[ii, ii] >= bound:
                a += '~'
            print a
    
    # tries to remove unhelpful vectors
    # we start at current = n-1 (last vector)
    def remove_unhelpful(BB, monomials, bound, current):
        # end of our recursive function
        if current == -1 or BB.dimensions()[0] <= dimension_min:
            return BB
    
        # we start by checking from the end
        for ii in range(current, -1, -1):
            # if it is unhelpful:
            if BB[ii, ii] >= bound:
                affected_vectors = 0
                affected_vector_index = 0
                # let's check if it affects other vectors
                for jj in range(ii + 1, BB.dimensions()[0]):
                    # if another vector is affected:
                    # we increase the count
                    if BB[jj, ii] != 0:
                        affected_vectors += 1
                        affected_vector_index = jj
    
                # level:0
                # if no other vectors end up affected
                # we remove it
                if affected_vectors == 0:
                    print "* removing unhelpful vector", ii
                    BB = BB.delete_columns([ii])
                    BB = BB.delete_rows([ii])
                    monomials.pop(ii)
                    BB = remove_unhelpful(BB, monomials, bound, ii-1)
                    return BB
    
                # level:1
                # if just one was affected we check
                # if it is affecting someone else
                elif affected_vectors == 1:
                    affected_deeper = True
                    for kk in range(affected_vector_index + 1, BB.dimensions()[0]):
                        # if it is affecting even one vector
                        # we give up on this one
                        if BB[kk, affected_vector_index] != 0:
                            affected_deeper = False
                    # remove both it if no other vector was affected and
                    # this helpful vector is not helpful enough
                    # compared to our unhelpful one
                    if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) < abs(bound - BB[ii, ii]):
                        print "* removing unhelpful vectors", ii, "and", affected_vector_index
                        BB = BB.delete_columns([affected_vector_index, ii])
                        BB = BB.delete_rows([affected_vector_index, ii])
                        monomials.pop(affected_vector_index)
                        monomials.pop(ii)
                        BB = remove_unhelpful(BB, monomials, bound, ii-1)
                        return BB
        # nothing happened
        return BB
    
    """ 
    Returns:
    * 0,0   if it fails
    * -1,-1 if `strict=true`, and determinant doesn't bound
    * x0,y0 the solutions of `pol`
    """
    def boneh_durfee(pol, modulus, mm, tt, XX, YY):
        """
        Boneh and Durfee revisited by Herrmann and May
        
        finds a solution if:
        * d < N^delta
        * |x| < e^delta
        * |y| < e^0.5
        whenever delta < 1 - sqrt(2)/2 ~ 0.292
        """
    
        # substitution (Herrman and May)
        PR.<u, x, y> = PolynomialRing(ZZ)
        Q = PR.quotient(x*y + 1 - u) # u = xy + 1
        polZ = Q(pol).lift()
    
        UU = XX*YY + 1
    
        # x-shifts
        gg = []
        for kk in range(mm + 1):
            for ii in range(mm - kk + 1):
                xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk
                gg.append(xshift)
        gg.sort()
    
        # x-shifts list of monomials
        monomials = []
        for polynomial in gg:
            for monomial in polynomial.monomials():
                if monomial not in monomials:
                    monomials.append(monomial)
        monomials.sort()
        
        # y-shifts (selected by Herrman and May)
        for jj in range(1, tt + 1):
            for kk in range(floor(mm/tt) * jj, mm + 1):
                yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk)
                yshift = Q(yshift).lift()
                gg.append(yshift) # substitution
        
        # y-shifts list of monomials
        for jj in range(1, tt + 1):
            for kk in range(floor(mm/tt) * jj, mm + 1):
                monomials.append(u^kk * y^jj)
    
        # construct lattice B
        nn = len(monomials)
        BB = Matrix(ZZ, nn)
        for ii in range(nn):
            BB[ii, 0] = gg[ii](0, 0, 0)
            for jj in range(1, ii + 1):
                if monomials[jj] in gg[ii].monomials():
                    BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY)
    
        # Prototype to reduce the lattice
        if helpful_only:
            # automatically remove
            BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1)
            # reset dimension
            nn = BB.dimensions()[0]
            if nn == 0:
                print "failure"
                return 0,0
    
        # check if vectors are helpful
        if debug:
            helpful_vectors(BB, modulus^mm)
        
        # check if determinant is correctly bounded
        det = BB.det()
        bound = modulus^(mm*nn)
        if det >= bound:
            print "We do not have det < bound. Solutions might not be found."
            print "Try with highers m and t."
            if debug:
                diff = (log(det) - log(bound)) / log(2)
                print "size det(L) - size e^(m*n) = ", floor(diff)
            if strict:
                return -1, -1
        else:
            print "det(L) < e^(m*n) (good! If a solution exists < N^delta, it will be found)"
    
        # display the lattice basis
        if debug:
            matrix_overview(BB, modulus^mm)
    
        # LLL
        if debug:
            print "optimizing basis of the lattice via LLL, this can take a long time"
    
        BB = BB.LLL()
    
        if debug:
            print "LLL is done!"
    
        # transform vector i & j -> polynomials 1 & 2
        if debug:
            print "looking for independent vectors in the lattice"
        found_polynomials = False
        
        for pol1_idx in range(nn - 1):
            for pol2_idx in range(pol1_idx + 1, nn):
                # for i and j, create the two polynomials
                PR.<w,z> = PolynomialRing(ZZ)
                pol1 = pol2 = 0
                for jj in range(nn):
                    pol1 += monomials[jj](w*z+1,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY)
                    pol2 += monomials[jj](w*z+1,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY)
    
                # resultant
                PR.<q> = PolynomialRing(ZZ)
                rr = pol1.resultant(pol2)
    
                # are these good polynomials?
                if rr.is_zero() or rr.monomials() == [1]:
                    continue
                else:
                    print "found them, using vectors", pol1_idx, "and", pol2_idx
                    found_polynomials = True
                    break
            if found_polynomials:
                break
    
        if not found_polynomials:
            print "no independant vectors could be found. This should very rarely happen..."
            return 0, 0
        
        rr = rr(q, q)
    
        # solutions
        soly = rr.roots()
    
        if len(soly) == 0:
            print "Your prediction (delta) is too small"
            return 0, 0
    
        soly = soly[0][0]
        ss = pol1(q, soly)
        solx = ss.roots()[0][0]
    
        #
        return solx, soly
    
    def example():
        #
        # The problem to solve (edit the following values)
        #
    
        # the modulus
        N = 0xbadd260d14ea665b62e7d2e634f20a6382ac369cd44017305b69cf3a2694667ee651acded7085e0757d169b090f29f3f86fec255746674ffa8a6a3e1c9e1861003eb39f82cf74d84cc18e345f60865f998b33fc182a1a4ffa71f5ae48a1b5cb4c5f154b0997dc9b001e441815ce59c6c825f064fdca678858758dc2cebbc4d27
        # the public exponent
        e = 0x11722b54dd6f3ad9ce81da6f6ecb0acaf2cbc3885841d08b32abc0672d1a7293f9856db8f9407dc05f6f373a2d9246752a7cc7b1b6923f1827adfaeefc811e6e5989cce9f00897cfc1fc57987cce4862b5343bc8e91ddf2bd9e23aea9316a69f28f407cfe324d546a7dde13eb0bd052f694aefe8ec0f5298800277dbab4a33bb
    
        # the hypothesis on the private exponent (the theoretical maximum is 0.292)
        delta = .18 # this means that d < N^delta
    
        #
        # Lattice (tweak those values)
        #
    
        # you should tweak this (after a first run), (e.g. increment it until a solution is found)
        m = 4 # size of the lattice (bigger the better/slower)
    
        # you need to be a lattice master to tweak these
        t = int((1-2*delta) * m)  # optimization from Herrmann and May
        X = 2*floor(N^delta)  # this _might_ be too much
        Y = floor(N^(1/2))    # correct if p, q are ~ same size
    
        #
        # Don't touch anything below
        #
    
        # Problem put in equation
        P.<x,y> = PolynomialRing(ZZ)
        A = int((N+1)/2)
        pol = 1 + x * (A + y)
    
        #
        # Find the solutions!
        #
    
        # Checking bounds
        if debug:
            print "=== checking values ==="
            print "* delta:", delta
            print "* delta < 0.292", delta < 0.292
            print "* size of e:", int(log(e)/log(2))
            print "* size of N:", int(log(N)/log(2))
            print "* m:", m, ", t:", t
    
        # boneh_durfee
        if debug:
            print "=== running algorithm ==="
            start_time = time.time()
    
        solx, soly = boneh_durfee(pol, e, m, t, X, Y)
    
        # found a solution?
        if solx > 0:
            print "=== solution found ==="
            if False:
                print "x:", solx
                print "y:", soly
    
            d = int(pol(solx, soly) / e)
            print "private key found:", d
        else:
            print "=== no solution was found ==="
    
        if debug:
            print("=== %s seconds ===" % (time.time() - start_time))
    
    if __name__ == "__main__":
        example()
    
    ```

  

