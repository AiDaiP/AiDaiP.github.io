# 没有对象如何面向对象
* #### 类&对象
  * ##### 定义类

    定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。 

    ```c++
    class girl_friend
    {
    public:
    	int age;
    	string name;
    	void set_name(string n)
    	{
    		name = n;
    	}
    	void set_age(int a)
    	{
    		age = a;
    	}
    };
    ```

    

  * ##### 定义对象

    对象是根据类来创建

    ```c++
    girl_friend gf1;
    girl_friend gf2;
    ```

  * ##### 访问数据成员

    访问数据成员

    public的成员可以直接使用” . “访问 

    `gf1.age`

    | 访问权限 | public | protected | private |
    | -------- | ------ | --------- | ------- |
    | 同一个类 | 有     | 有        | 有      |
    | 派生类   | 有     | 有        | 无      |
    | 外部类   | 有     | 无        | 无      |

  * ##### this指针

    每个对象都有一个this指针，this指针指向当前对象

    当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象的this指针作为一个隐含参数传递给函数

    ```c++
    class girl_friend
    {
    public:
    	int age;
    	string name;
    	void fun()
    	{
    		cout << this->age << endl;
    		//cout << age << endl;
    		cout << (*this).name << endl;
    		//cout << name << endl;
    	}
    	girl_friend fun1()
    	{
    		return *this;//返回对象拷贝
    	}
    	girl_friend &fun2()
    	{
    		return *this;//返回对象引用
    	}
    	girl_friend* fun3()
    	{
    		return this;//返回对象指针
    	}
    };
    
    ```

    

    

  * ##### 静态成员

    使用static可以把类成员定义为静态的

    static修饰的类成员属于类，不属于对象

    * ###### 静态成员数据

      static成员变量是所有对象共享的变量，先于对象存在，所以必须在类外进行初始化

      ```c++
      class girl_friend
      {
      public:
      	static int age;
      	string name;
      };
      int girl_friend::age = 0;
      
      
      int main()
      {
      	girl_friend gf1;
      	cout << gf1.age;//0
      	gf1.age = 1;
      	girl_friend gf2;
      	cout << gf2.age;//1
      	girl_friend::age = 2;
      	cout << gf1.age;//2
      }
      
      
      ```

      static成员变量在静态储存区生成，不与对象一起生成，在对象中不占内存，可以节省对象的内存空间

    * ##### 静态成员函数

      static类成员属于类，不属于对象，所以static类成员函数没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static类成员。

      ```c++
      class girl_friend
      {
      public:
      
      	static int age;
      	string name;
      	static void fun()
      	{
      		cout << age;
      		//cout << name;报错
      	}
      };
      int girl_friend::age = 0;
      ```

      

  * ##### 友元函数

    类的友元函数定义在类外部，但有权访问类的所有成员。

    友元函数的原型在类的定义中出现过，但是友元函数并不是成员函数。

    友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，友元类的所有成员函数都是友元函数。

    声明友元使用关键字friend

    ```c++
    #include<iostream>
    #include<string>
    using namespace std;
    
    class girl_friend
    {
    public:
    	int age;
    	void set_name(string n)
    	{
    		name = n;
    	}
    	friend void get_name(girl_friend gf);//友元函数
    	friend class Get_name;//友元类
    private:
    	string name;
    };
    
    void get_name(girl_friend gf)
    {
    	cout << gf.name;
    }
    
    class Get_name
    {
    public:
    	void get_name(girl_friend gf)
    	{
    		cout << gf.name;
    	}
    };
    
    int main()
    {
    	girl_friend gf1;
    	Get_name g;
    	gf1.set_name("123");
    	g.get_name(gf1);
    	get_name(gf1);
    }
    
    ```

    * 注意事项
      1. 友元函数不能被继承
      2. 友元关系是单向的，B是A的友元，A不一定是B的友元
      3. 友元关系不具有传递性，B是A的友元，C是B的友元，C不一定是A的友元
      4. 友元函数没有this指针，访问非static成员时需要对象做参数，访问static成员或全局变量时，则不需要对象做参数； 如果做参数的对象是全局对象，则不需要对象做参数；
      5. 友元函数可以直接调用，不需要通过对象或指针

  * ##### 构造函数
    - ###### 构造函数

      类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数就是构造函数

      构造函数的名字与类名相同，有一个参数列表和一个函数体，无返回类型。

    - ###### 默认构造函数

      类中没有显式的定义构造函数，编译器就会隐式的定义一个默认构造函数

      默认构造函数无实参

      初始化规则：如果存在类内初始值，用它初始化成员，否则默认初始化成员。

      类中可以有多个构造函数，如果既需要其他形式的构造函数，也需要默认的构造函数，就需要定义一个默认构造函数

      ```c++
      class girl_friend
      {
      public:
      	girl_friend()=default;//默认构造函数
      	string name;
      };
      ```

    - ###### 自定义构造函数

      ```c++
      class girl_friend
      {
      public:
      	girl_friend(string &n,int &a):name(n),age(a)
      	{
      		cout << "Girl_friend is being created" << endl;
      	}
      	string name;
      	int age;
      	int height;
      };
      ```

      其中冒号后为构造函数初始值列表，每个成员名字后的括号内是成员初始值。

      其中`height`没有显式初始化，按照默认构造函数的方式隐式初始化。

      也可以在构造函数内赋值

      ```c++
      class girl_friend
      {
      public:
      	girl_friend(string &n,int &a)
      	{
      		name = n;
      		age = a;
      		cout << "Girl_friend is being created" << endl;
      	}
      	string name;
      	int age;
      	int height；
      };
      ```

      如果没有在构造函数的初始值列表中显式的初始化成员，该成员将在构造函数体之前默认初始化。

      类成员初始化总在构造函数执行之前，这会导致在构造函数内赋值出现问题。

      如果成员是const就无法赋值，而引用类型必须在初始化时必须有初值，所以对于const和引用类型在构造函数内赋值会出现错误，应该使用冒号初始化。

      

    - ###### 拷贝构造函数

      拷贝构造函数在创建对象时使用同一类中之前创建的对象来初始化新的对象。

      如果没有显式定义拷贝构造函数，编译器就会隐式的定义一个默认拷贝构造函数。

      ```c++
      class girl_friend
      {
      public:
      	girl_friend(const girl_friend &gf1)=default；
      };
      ```

      ```c++
      girl_friend gf1;//直接初始化，调用默认构造函数
      girl_friend gf2 = gf1;//拷贝初始化，调用默认拷贝构造函数
      ```

      冒号初始化

      ```c++
      class girl_friend
      {
      public:
      	girl_friend(girl_friend &gf1):name(gf1.name),age(gf1.age)
      	{
      		cout << "Girl_friend is being created" << endl;
      	}
      	string name;
      	int age;
      };
      ```

      函数体内赋值

      ```c++
      class girl_friend
      {
      public:
      	girl_friend(girl_friend &gf1)
      	{
      		cout << "Girl_friend is being created" << endl;
      		name = gf1.name;
      		age = gf1.age;
      	}
      	string name;
      	int age;
      };
      ```

      ```c++
      girl_friend gf3(gf1)//拷贝初始化，调用拷贝构造函数
      ```

      

    - ###### 在类的外部定义构造函数

      ```c++
      class girl_friend
      {
      public:
      	girl_friend(string &n,int &a);
      	string name;
      	int age;
      	int height；
      };
      
      girl_friend::girl_friend(string &n,int &a):name(n),age(a)
      	{
      		cout << "Girl_friend is being created" << endl;
      	}
      
      ```

      在类中声明，在外部定义

      

  * ##### 析构函数

      析构函数删除所创建的对象

      析构函数名字与类名相同，前面加`~`，没有参数和返回值

      如果没有显式定义析构函数，编译器就会隐式的定义一个默认析构函数

      ```c++
        class girl_friend
        {
        public:
        girl_friend()
        {
        	cout << "Girl_friend is being created" << endl;
        }
        ~girl_friend()
        {
        	cout << "Girl_friend is being destroyed" << endl;
        }
        };
      ```

   

  * ##### new和delete运算符

    在回收用 new 分配的单个对象的内存空间的时候用 delete，回收用 new 分配的一组对象的内存空间的时候用 delete[]。 

    new 会调用构造函数，delete会调用析构函数，delete[] 调用每个数组元素的析构函数。

    ```c++
    class girl_friend
    {
    public:
    	girl_friend()
    	{
    		cout << "Girl_friend is being created" << endl;
    	}
    	~girl_friend()
    	{
    		cout << "Girl_friend is being destroyed" << endl;
    	}
    };
    
    int main()
    {
    	girl_friend* gf = new girl_friend[2];
    	delete[] gf;
    	cout << "==========" << endl;
    	girl_friend* gf1 = new girl_friend;
    	delete gf1;
        //delete[] gf1;错误
    }
    
    /*
    Girl_friend is being created
    Girl_friend is being created
    Girl_friend is being destroyed
    Girl_friend is being destroyed
    ==========
    Girl_friend is being created
    Girl_friend is being destroyed
    */
    ```

    

* #### 继承

  创建一个类时，可以不重新编写新的数据成员和成员函数，指定新建的类继承了一个已有的类的成员。

  继承代表 **is a** 关系 

  已有的类称为基类，新建的类称为派生类，一个类可以派生自多个类，它可以从多个基类继承数据和函数。 

  A派生B，B派生C，A是B的直接基类，B是C的直接基类，A是C的间接基类，

  声明派生类时，使用类派生列表来指定基类，只需要列出直接基类，派生类自动向上继承简洁基类

  ```c++
  class people
  {
  public:
  	int age;
  	string name;
  };
  class find_girfriend
  {
  public:
  	void find()
  	{
  		cout << "finding..." << endl;
  		cout << "you cann't find girlfriend" << endl;
  	}
  };
  class damn_single : public people, public find_girfriend
  {
  public:
  	void single()
  	{
  		cout << "you don't have girlfriend" << endl;
  	}
  };//damn_single是people和find_girfriend的派生类
  ```

  一个派生类继承了所有的基类方法，但下列情况除外：

  - 基类的构造函数、析构函数和拷贝构造函数。
  - 基类的重载运算符。
  - 基类的友元函数。

  派生类对象包含基类对象，基类对象的储存位置位于派生类对象新增的成员之前

  * ##### 继承类型

    - **公有继承（public）：**基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。

    - **保护继承（protected）：** 基类的**公有**和**保护**成员将成为派生类的**保护**成员。

    - **私有继承（private）：**基类的**公有**和**保护**成员将成为派生类的**私有**成员。

      

  * 同名成员

    派生类与基类存在同名成员时，基类成员会被隐藏，派生类中存在基类成员的拷贝，可以通过base::name访问

    ```c++
    class people
    {
    public:
    	int age;
    	char* name;
    };
    class find_girfriend
    {
    public:
    	void single()
    	{
    		cout << "Use 'find()' to find girlfriend" << endl;
    	}
    	void find()
    	{
    		cout << "you cann't find girlfriend" << endl;
    	}
    	int  years = 18;
    };
    class damn_single : public people, public find_girfriend
    {
    public:
    	void single()
    	{
    		cout << "you don't have girlfriend" << endl;
    	}
    	int years = 19;
    };
    
    int main()
    {
    	damn_single ds;
    	ds.find_girfriend::single();
    	ds.single();
    	cout << ds.find_girfriend::years << endl;
    	cout << ds.years << endl;
    }
    /*
    Use 'find()' to find girlfriend
    you don't have girlfriend
    18
    19
    */
    
    ```

    

  * ##### 派生类的构造函数

    创建派生类对象时需要调用基类的构造函数初始化从基类继承的成员

    在执行派生类的构造函数前先执行基类的构造函数

    ```c++
    class people
    {
    public:
    	people(int a) :age(a)
    	{
    		cout << "people is being created" << endl;
    	}
    	int age;
    };
    class girl_friend : public people
    {
    public:
    	girl_friend(int a, bool b) :people(a), age(a), isGirl(b)
    	{
    		cout << "Girl_friend is being created" << endl;
    	}
    	int age;
    	bool isGirl;
    };
    
    int main()
    {
    	girl_friend gf(1, true);
    }
    /*
    people is being created
    Girl_friend is being created
    */
    ```

    派生类的构造函数为基类的构造函数提供参数

    派生类的构造函数省略基类构造函数时默认调用基类的默认构造函数

  * ##### 派生类的析构函数

    派生类的析构函数执行后，自动调用基类的析构函数

    ```c++
    class people
    {
    public:
    	people(int a) :age(a)
    	{
    		cout << "people is being created" << endl;
    	}
    	~people()
    	{
    		cout << "People is being destroyed" << endl;
    	}
    	int age;
    };
    class girl_friend : public people
    {
    public:
    	girl_friend(int a, bool b) :people(a), age(a), isGirl(b)
    	{
    		cout << "Girl_friend is being created" << endl;
    	}
    	~girl_friend()
    	{
    		cout << "Girl_friend is being destroyed" << endl;
    	}
    	int age;
    	bool isGirl;
    };
    
    
    int main()
    {
    	girl_friend gf(1, true);
    	gf.~girl_friend();
    }
    /*
    people is being created
    Girl_friend is being created
    Girl_friend is being destroyed
    People is being destroyed
    */
    ```

    

* #### 运算符重载和重载函数

  ```
  (5,5)++ == (5, 5)
  ++(5,5) == (6,6)
  (5,5) & (6,6) == (4,4)
  (5,5) >> 2 == (1,1)
  ```

  ```c++
  #include<iostream>
  
  using namespace std;
  
  class point
  {
  public:
  	int x = 0;
  	int y = 0;
  	void show_point()
  	{
  		cout << "(" << x << "," << y << ")" << endl;
  	}	
  	point operator ++()
  	{
  		++x;
  		++y;
  		return *this;
  	}
  	point operator ++(int)
  	{
  		return *this;
  	}
  	point operator >> (int n)
  	{
  		x = x >>n;
  		y = y >>n;
  		return *this;
  	}
  	point operator &(point p)
  	{
  		x = x & p.x;
  		y = y & p.y;
  		return *this;
  	}
  };
  
  int main()
  {
  	point a, b, c;
  	int o, n;
  	cout << "输入a坐标" << endl;
  	cin >> a.x >> a.y;
  	cout << "1:a++;2:++a;3:a&b;4:a>>n" << endl;
  	cin >> o;
  	switch (o)
  	{
  	case 1:
  		c = a++;
  		c.show_point();
  		break;
  	case 2:
  		c = ++a;
  		c.show_point();
  		break;
  	case 3:
  		cout << "输入b坐标" << endl;
  		cin >> b.x >> b.y;
  		c = a & b;
  		c.show_point();
  		break;
  	case 4:
  		cout << "输入n" << endl;
  		cin >> n;
  		c = a >> n;
  		c.show_point();
  		break;
  	default:
  		cout << "Error" << endl;
  	}
  }
  ```

  

  

  