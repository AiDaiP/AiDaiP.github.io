今天看了一波C++面向对象

从入门到放弃

* 定义类

  定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。 

  ```C++
  class girl_friend
  {
  public:
  	int age;
  	string name;
  	void set_name(string n)
  	{
  		name = n;
  	}
  	void set_age(int a)
  	{
  		age = a;
  	}
  }
  ```

* 定义对象

  对象是根据类来创建

  ```C++
  girl_friend gf1;
  girl_friend gf2;
  ```

* 继承

  创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员

  ```C++
  class people
  {
  public:
  	int age;
  	string name;
  };
  class find_girfriend
  {
  public:
  	void find()
  	{
  		cout << "finding..." << endl;
  		cout << "you cann't find girlfriend" << endl;
  	}
  };
  class damn_single : public girl_friend, public find_girfriend
  {
  public:
  	void single()
  	{
  		cout << "you don't have girlfriend" << endl;
  	}
  };
  ```

  

* 访问数据成员

  public的成员可以直接使用” . “访问 

  `gf1.age`

  | 访问权限 | public | protected | private |
  | -------- | ------ | --------- | ------- |
  | 同一个类 | 有     | 有        | 有      |
  | 派生类   | 有     | 有        | 无      |
  | 外部类   | 有     | 无        | 无      |

* 运算符重载

  可用重定义或重载大部分 C++ 内置的运算符 

  搞一个点类试一波这个样例

  ```
  (5,5)++ == (5, 5)
  ++(5,5) == (6,6)
  (5,5) & (6,6) == (4,4)
  (5,5) >> 2 == (1,1)
  ```

  ```C++
  #include<iostream>
  
  using namespace std;
  
  class point
  {
  public:
  	int x = 0;
  	int y = 0;
  	void show_point()
  	{
  		cout << "(" << x << "," << y << ")" << endl;
  	}	
  	point operator ++()
  	{
  		++x;
  		++y;
  		return *this;
  	}
  	point operator ++(int)
  	{
  		return *this;
  	}
  	point operator >> (int n)
  	{
  		x = x >>n;
  		y = y >>n;
  		return *this;
  	}
  	point operator &(point p)
  	{
  		x = x & p.x;
  		y = y & p.y;
  		return *this;
  	}
  };
  
  int main()
  {
  	point a, b, c;
  	int o, n;
  	cout << "输入a坐标" << endl;
  	cin >> a.x >> a.y;
  	cout << "1:a++;2:++a;3:a&b;4:a>>n" << endl;
  	cin >> o;
  	switch (o)
  	{
  	case 1:
  		c = a++;
  		c.show_point();
  		break;
  	case 2:
  		c = ++a;
  		c.show_point();
  		break;
  	case 3:
  		cout << "输入b坐标" << endl;
  		cin >> b.x >> b.y;
  		c = a & b;
  		c.show_point();
  		break;
  	case 4:
  		cout << "输入n" << endl;
  		cin >> n;
  		c = a >> n;
  		c.show_point();
  		break;
  	default:
  		cout << "Error" << endl;
  	}
  }
  ```

  写的时候发现了返回对象和返回对象引用的问题

  如果是`point operator ++()`

  `return *this`就是返回对象的拷贝

  如果是`point & operator ++()`

  `return *this`就是返回对象的引用

  返回对象和返回对象的引用这些东西还得再搞一搞，现在还是有点迷



C++从入门到放弃，明天继续