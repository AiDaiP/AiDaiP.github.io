# 算法从入门到放弃-1
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
* 算法的度量

  * Big O

    如果存在正数c和N，对于所有的$n>=N$，有$f(n)<=cg(n)$，则$f(n)=O(g(n))$ 

    Big O 是一个算法最坏情况的度量

  * Big Omega 

    如果存在正数c和N，对于所有的$n>=N$，有$f(n)>=cg(n)$，则$f(n)=Ω(g(n))$

    Big Omega 是一个算法最好情况的度量

  * Big Theta 

    如果存在正数c1,c2和N，对于所有的$n>=N$，有$c1g(n)<=f(n)<=c2g(n)$，则$f(n)=θ(g(n))$

    Big Theta 表达了一个算法的区间 

  常用Big O

  

* Big O分析

  常见的输入输出以及简单的赋值语句，可以认为时间复杂度是 $O(1)$ 

  计算复杂度时乘以一个常数复杂度不变，即$O(cf(n))=O(f(n))$

  程序的基本结构有三种，顺序结构，选择机构，循环结构

  * 计算复杂度的基本法则
    * 顺序结构

      通过求和法则来进行计算

      算法的两个部分时间复杂度分别为 $T1(n)=O(f(n))$ 和 $T2(n)=O(g(n))$，则$T1(n)+T2(n)=O(max(f(n),g(n)))$

      算法的 两 个部分时间复杂度分别为 $T1(m)=O(f(m)) 和 T2(n)=O(g(n))$，则

      $T1(m)+T2(n)=O(f(m)+g(n))$

    * 选择结构

      判断条件的时间复杂度为 $O(1)$ 

    * 循环结构

      使用乘法法则

      若两个部分时间复杂度分别为 $T1(n)=O(f(n))$ 和 ，$T2(n)=O(g(n))$则 $T1T2=O(f(n)g(n))$

  * 递归的时间复杂度计算

    当一个算法中包含递归调用时，其时间复杂度的分析会转化为一个递归方程求解 

    * 递归树法

      例：

      ![1](https://raw.githubusercontent.com/AiDaiP/AiDaiP.github.io/master/images/算法入门到放弃1/1.png)

      ![2](https://raw.githubusercontent.com/AiDaiP/AiDaiP.github.io/master/images/算法入门到放弃1/2.png)

      时间复杂度等于树高与每层数据量之和

    * 主定理法

      对于形如$T(n) = aT(n/b) + f(n)$的递归方程

      ![3](https://raw.githubusercontent.com/AiDaiP/AiDaiP.github.io/master/images/算法入门到放弃1/3.jpg)

    * 迭代法

      把递归方程右边展开，直到没有可以迭代的项为止，通过对右边的和进行估算来估计方程的解

      对于递归方程`T(n)=2T(n/2)+n2 `

      ![4](https://raw.githubusercontent.com/AiDaiP/AiDaiP.github.io/master/images/算法入门到放弃1/4.png)

    * 代入法

      代入法的基本步骤是先推测递归方程的显式解，然后用数学归纳法来验证该解是否合理

      

* 数据结构

  * 数组

    数组是可以在内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问。

    * 优点： 

      1、按照索引查询元素速度快 
      2、按照索引遍历数组方便

    * 缺点： 

      1、数组的大小固定后就无法扩容了 
      2、数组只能存储一种类型的数据 
      3、添加，删除的操作慢，因为要移动其他的元素。

    

  * 链表

    链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。

    * 优点： 

      1、链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素； 
      2、添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；

    * 缺点： 

      1、因为含有大量的指针域，占用空间较大； 
      2、查找元素需要遍历链表来查找，非常耗时。

    

  * 栈

    栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作，先进后出。栈顶放入元素的操作称为入栈，取出元素称为出栈。

    * 支持的操作：
      push - 入栈

      peek - 查看栈顶

      pop - 弹出栈顶元素

    * 实现方式
      数组实现（需要一个变量来标记栈顶位置）

      链表实现（插入元素时注意对表头的操作 ）

  * 队列

    队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素先进先出。从一端放入元素的操作称为入队列，取出元素称为出队列。

    - 支持的操作：

      Enqueue - 入队列

      Dequeue - 出队列

    - 实现方式

      数组实现（需要一个变量来标记队列头及队列尾的位置）

      链表实现（需要保存表尾，处理表头的时候注意操作顺序）

      

  * 树

    树是一种能够分层存储数据的重要数据结构，是由n（n>=1）个有限节点组成一个具有层次关系的集合。树中的每个元素被称为树的节点，每个节点有若干个指针指向子节点。从节点的角度来看，树是由唯一的起始节点引出的节点集合。这个起始结点称为根(root)。树中节点的子树数目称为节点的度(degree) 

    * 特点

      1、每个节点有零个或多个子节点；

      2、没有父节点的节点称为根节点；

      3、每一个非根节点有且只有一个父节点；

      4、除了根节点外，每个子节点可以分为多个不相交的子树；

    * 二叉树

      二叉树是一种常见的特殊的树

      * 特点

        1、每个结点最多有两颗子树，结点的度最大为2

        2、左子树和右子树有顺序，次序不能颠倒。

        3、即使某结点只有一个子树，也要区分左右子树。 

  * 图

    图由结点的有穷集合V和边的集合E组成

    * 有向图

      有向图的边具有指向性，即AB仅表示由A到B的路径，但并不意味着B可以连到A

    * 无向图

      无向图的每条边都表示一条双向路径。 

      ![6](https://raw.githubusercontent.com/AiDaiP/AiDaiP.github.io/master/images/算法入门到放弃1/6.png)

  * 堆

    n个元素的序列$\{k1,k2,ki,…,kn\}$当且仅当满足下关系时，称之为堆。

    $(ki <= k2i,ki <= k2i+1)或者(ki >= k2i,ki >= k2i+1), (i = 1,2,3,4...n/2)$

    满足前者的表达式的称为小顶堆，满足后者表达式的称为大顶堆

    ![5](https://raw.githubusercontent.com/AiDaiP/AiDaiP.github.io/master/images/算法入门到放弃1/5.png)

    堆可以被看做一棵树的数组对象，堆中某个节点的值总是不大于或不小于其父节点的值，堆总是一棵完全二叉树，将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆

  * 散列表

    散列表，也叫哈希表，是根据关键码（Key）和值（value）直接进行访问的数据结构，通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。

    若关键字为k，则其值存放在f(k)的存储位置上。称这个对应关系f为散列函数，按这个思想建立的表为散列表。

    对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为冲突

    
