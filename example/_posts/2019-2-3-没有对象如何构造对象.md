# 没有对象如何构造对象

没对象构造一个就完事了



* 构造函数

  类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数就是构造函数

  构造函数的名字与类名相同，有一个参数列表和一个函数体，无返回类型。

* 默认构造函数

  类中没有显式的定义构造函数，编译器就会隐式的定义一个默认构造函数

  默认构造函数无实参

  初始化规则：如果存在类内初始值，用它初始化成员，否则默认初始化成员。

  类中可以有多个构造函数，如果既需要其他形式的构造函数，也需要默认的构造函数，就需要定义一个默认构造函数

  ```c++
  class girl_friend
  {
  public:
  	girl_friend()=default;//默认构造函数
  	string name;
  };
  ```

* 自定义构造函数

  ```c++
  class girl_friend
  {
  public:
  	girl_friend(string &n,int &a):name(n),age(a)
  	{
  		cout << "Girl_friend is being created" << endl;
  	}
  	string name;
  	int age;
  	int height;
  };
  ```

  其中冒号后为构造函数初始值列表，每个成员名字后的括号内是成员初始值。

  其中`height`没有显式初始化，按照默认构造函数的方式隐式初始化。

  也可以在构造函数内赋值

  ```c++
  class girl_friend
  {
  public:
  	girl_friend(string &n,int &a)
  	{
  		name = n;
  		age = a;
  		cout << "Girl_friend is being created" << endl;
  	}
  	string name;
  	int age;
  	int height；
  };
  ```

  如果没有在构造函数的初始值列表中显式的初始化成员，该成员将在构造函数体之前默认初始化。

  类成员初始化总在构造函数执行之前，这会导致在构造函数内赋值出现问题。

  如果成员是const就无法赋值，而引用类型必须在初始化时必须有初值，所以对于const和引用类型在构造函数内赋值会出现错误，应该使用冒号初始化。

  

* 拷贝构造函数

  拷贝构造函数在创建对象时使用同一类中之前创建的对象来初始化信的对象。

  如果没有显式定义拷贝构造函数，编译器就会隐式的定义一个默认拷贝构造函数。

  ```c++
  class girl_friend
  {
  public:
  	girl_friend(const girl_friend &gf1)=default；
  };
  ```

  ```c++
  girl_friend gf1;//直接初始化，调用默认构造函数
  girl_friend gf2 = gf1;//拷贝初始化，调用默认拷贝构造函数
  ```

  冒号初始化

  ```c++
  class girl_friend
  {
  public:
  	girl_friend(girl_friend &gf1):name(gf1.name),age(gf1.age)
  	{
  		cout << "Girl_friend is being created" << endl;
  	}
  	string name;
  	int age;
  };
  ```

  函数体内赋值

  ```c++
  class girl_friend
  {
  public:
  	girl_friend(girl_friend &gf1)
  	{
  		cout << "Girl_friend is being created" << endl;
  		name = gf1.name;
  		age = gf1.age;
  	}
  	string name;
  	int age;
  };
  ```

  ```c++
  girl_friend gf3(gf1)//拷贝初始化，调用拷贝构造函数
  ```

  

* 在类的外部定义构造函数

  ```c++
  class girl_friend
  {
  public:
  	girl_friend(string &n,int &a);
  	string name;
  	int age;
  	int height；
  };
  
  girl_friend::girl_friend(string &n,int &a):name(n),age(a)
  	{
  		cout << "Girl_friend is being created" << endl;
  	}
  
  ```

  在类中声明，在外部定义

* 析构函数

  析构函数删除所创建的对象

  析构函数名字与类名相同，前面加`~`，没有参数和返回值

  如果没有显式定义析构函数，编译器就会隐式的定义一个默认析构函数

  ```c++
  class girl_friend
  {
  public:
  	girl_friend()
  	{
          cout << "Girl_friend is being created" << endl;
  	}
  	~girl_friend()
  	{
          cout << "Girl_friend is being destroyed" << endl;
  	}
  };
  ```

  



