#  RSA从入门到入土

* #### 数学知识

  * ##### 互质

    如果两个或两个以上的整数的最大公约数是 1，则称它们为互质

    任意两个质数构成互质关系

  * ##### 同余

    给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，那么就称整数a与b对模m同余，记作$$a≡b(mod\ m)$$

  * ##### 模反元素

    如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。这时，b就叫做a对模数n的“模反元素” 。 

    即 $$ab≡1 (mod\  n)​$$

  * ##### 扩展欧几里得算法

    扩展欧几里德算法是用来在已知a, b时，求解一组x，y，使它们满足贝祖等式 $$ax+by = gcd(a, b)$$

    

  * ##### 欧拉函数

    对正整数n，欧拉函数φ(n)是小于或等于n的正整数中与n互质的数的数目

    欧拉函数是积性函数，若m,n互质，则 $$φ(mn)=φ(m)φ(n)$$

    若n为质数，则 $$φ(n)=n-1$$

    

  * ##### 欧拉定理

    若n,a为正整数，且n,a互质，则 $$a^{φ(n)}=1\ (mod\ n)$$

    

* #### 密钥生成

  1. 随机选择两个不相等的质数p、q

     $$p=14214677$$

     $$q=15733001$$

     

  2. 计算p、q乘积n

     $$n=p× q=223639527455677$$

  3. 计算φ(n)

     $$φ(n)=(p-1)(q-1)=14214676×15733000=‭223639497508000‬$$

  4. 随机选择一个整数$$e$$  ($$1<e<φ(n)$$且e与φ(n) 互质)

     $$e=30001$$

  5. 计算e对于φ(n)的模反元素d

     $$ed≡1\ (mod\ φ(n))$$ 

     变形，得到一个二元一次方程

     $$ed-kφ(n)=1$$

     $$30001d-‭223639497508000k=1$$

     可以看作

     $$30001x+223639497508000y=gcd(30001,223639497508000k)=1$$

     使用扩展欧几里得算法求解，得到

     $$(x,y)=(223639497508000,-30000)$$

     $$d=223639497508000$$

  6. 将n和e封装成公钥，n和d封装成私钥

     公钥$$(223639527455677,30001)$$

     私钥$$(223639527455677,223639497508000)$$

     

     

* #### 加密与解密

  * 公钥加密

    $$m^e≡c (mod\ n)$$ 

    m为明文，c为密文，加密就是计算c

    加密“flag”

    m=0x666c6167=‭1718378855‬

    $$‭1718378855^{30001} ≡c (mod\ 223639527455677)$$

    解得$$c=191215680523649$$

    

  * 私钥解密

    $$c^d≡m\ (mod\ n)$$ 

    $$191215680523649^{223639497508000}≡m\ (mod\ 223639527455677)$$

    解得$$m=‭1718378855$$

    转化为字符串得到“flag”

    

    解密方法的证明

    证：$$c^d≡m\ (mod\ n)$$ 

    由加密规则可得

    $$c=m^e-kn$$

    代入，即证：

    $$(m^e-kn)^d≡ m\ (mod\ n)$$

    左边展开后除了第一项，其余项均模n余0，即证：

    $$m^{ed}≡m\ (mod\ n)$$ 

    d为e对于φ(n)的模反元素，所以

    $$ed=hφ(n)+1$$ 

    代入，即证：

    $$m^{hφ(n)+1}≡m\ (mod\ n)$$

    1. m、n互质

       根据欧拉定理可得

        $$m^{φ(n)}=1\ (mod\ n)$$

       所以

       $$m(m^{φ(n)})^h=m\ (mod\ n)$$

       即

       $$m^{hφ(n)+1}≡m\ (mod\ n)$$

       

    2. m、n不互质

       n的因数为1，n，p，q，若m、n不互质，必然有$$m=kp$$ 或 $$m=kq$$

       不妨设 $$m=kp$$

       $$m<n$$ 所以 $$k<q$$，k与q一定互质，kp和q互质，所以

       $$(kp)^{φ(q)}≡1\ (mod\ q)​$$

       即

       $$(kp)^{q-1}≡1\ (mod\ q)$$

       所以

       $$[kp^{(q-1)}]^{h(p-1)}kp≡kp\ (mod\ q)​$$

       即

       $$(kp)^{ed}≡kp\ (mod\ q)$$

       $$(kp)^{ed}=tq+kp$$

       $$(kp)^{ed}$$和$$kp$$能被p整除，所以t一定能被p整除

       设$$t=ap$$

       $$(kp)^{ed}=apq+kp$$

       即

       $$m^{ed}=an+kp$$

       所以

       $$m^{ed}≡m\ (mod\ n)​$$ 

       

* #### 快速幂取模

  * ##### 同余定理

    ```
    (a +/- b) % c = (a % c +/- b % c) % c 
    
    (a * b) % c = (a % c) * (b % c) % c 
    
    ab % c = (a % c)b % c
    ```

   * ##### 代码实现

     ```python
     def quick_mod(a,b,c):
         ans = 1
         t = a % c
         while b:
             if b & 1:
                 ans = (ans * t) % c
             t = (t * t) % c
             b >>= 1
         return ans
     ```

     

* #### 小公钥指数攻击

  * ##### 条件

    e特别小，如e = 3

  * ##### 原理

    $$c≡m^{e}\ (mod\ n)​$$ 

    $$ m^{e} = c + kn ​$$

    $$ m = (c + kn)^{1/e} ​$$

    枚举k，开e次根，直到开出整数

    **[Jarvis-OJ-extremely-hard-rsa](https://aidaip.github.io/example/2019-02-12-Jarvis-OJ-%E4%BB%8E%E6%89%93%E5%BC%80%E7%BD%91%E7%AB%99%E5%88%B0%E5%8E%BB%E4%B8%96/#extremely-hard-rsa)**

    

* #### Rabin算法

  * ##### 条件

    n = 2

  * ##### 原理

    $$c=m^{2}\ mod\ n$$ 

    $$m_p =\sqrt{c}\ mod\ p $$

    $$m_q =\sqrt{c}\ mod\ q $$

    

    若$$p≡q≡3\ (mod\ 4)​$$

    $$m_p = c^{1/4(p+1)}\ mod\ p​$$

    $$m_q = c^{1/4(q+1)}\ mod\ q$$

    $$y_pp+y_qq=1$$

    $$gcdext(p,q)$$解出$$y_p,y_q$$

    解出四个明文

    $$a = (y_ppm_q+y_qq_mp)\ mod\ n​$$

    $$ b = n -a​$$

    $$c = (y_ppm_q-y_qq_mp)\ mod\ n$$

    $$d = n - c$$

    **[Jarvis-OJ-hard-rsa](https://aidaip.github.io/example/2019-02-12-Jarvis-OJ-%E4%BB%8E%E6%89%93%E5%BC%80%E7%BD%91%E7%AB%99%E5%88%B0%E5%8E%BB%E4%B8%96/#hard-rsa)**

* #### 共模攻击

  * ##### 条件

    用相同的n不同的e对明文ｍ加密

  * ##### 原理

    $$c_1 ≡ m^{e_1} (mod\ n)​$$

    $$c_2 ≡ m^{e_2} (mod\ n)​$$

    $$gcd(e_1,e_2) = 1$$

    存在$$s_1,s_2​$$使$$s_1e_1+s_2e_2 = 1​$$

    $$c_1≡m^{e_1}\ (mod\ n)​$$ 

    $$c_2≡m^{e_2}\ (mod\ n)​$$ 

    所以

    $$c_1^{s_1}c_2^{s_2}≡(m^{e_1})^{s_1}(m^{e_2})^{s_2}\ (mod\ n)​$$ 

    $$c_1^{s_1}c_2^{s_2}≡m^{e_1s_1+e_2s_2}\ (mod\ n)​$$ 

    $$c_1^{s_1}c_2^{s_2}≡m\ (mod\ n)$$ 

    **[Jarvis-OJ-very-hard-rsa](https://aidaip.github.io/example/2019-02-12-Jarvis-OJ-%E4%BB%8E%E6%89%93%E5%BC%80%E7%BD%91%E7%AB%99%E5%88%B0%E5%8E%BB%E4%B8%96/#very-hard-rsa)**

* #### Wiener's attack

  * ##### 条件

    $$d<1/3N^{1/4}$$

  * ##### 原理

    [Wiener's attack](https://en.wikipedia.org/wiki/Wiener%27s_attack)

    [rsa-wiener-attack](https://github.com/pablocelayes/rsa-wiener-attack)

  

* #### Factoring with High Bits Known

  * ##### 条件

    已知N的一个因子的较高位

    ![coppersmith1](D:\Ai\coppersmith1.png)

    ```
    p.bit_length() == 1024 ,p的高位需已知约576位
    p.bit_length() == 512 ,p的高位需已知约288位
    ```

  * 例子

    ```sage
    '''
    n = 110884890902749085253001083431222443088115610795940152564793628519927092107501946446399003764508722709710121804620193329162066855289179887539537634989483300155392790067446377224025966917227342075570751172611456818461296838516185655681858001119900898375522640670694604696426035782721144065487316221499661637517
    e = 65537
    c = 56d1b214082fd508567e0a4e101dcaa4f3edf262d7330cae4d75d94b874f53dfe3c9ba66d62a41b7e9331e67ae6907e3c028701e53555fea0832b2908471d04ceb98dbedf576a504902d50c3c32050fa036573de4f466f9c5de6b6bd4ad2f96bd6cd235a62c6c9555eb5ecf5b793b514f60d3e75a8307983c0f1aab746477a7b
    front = 754471047130831460574350468751127056146566410666010180184022324900851348720910487519
    backLength = 512 - front.bit_length()
    '''
    
    import binascii
    n=110884890902749085253001083431222443088115610795940152564793628519927092107501946446399003764508722709710121804620193329162066855289179887539537634989483300155392790067446377224025966917227342075570751172611456818461296838516185655681858001119900898375522640670694604696426035782721144065487316221499661637517
    cipher = 0x56c5afbc956157241f2d4ea90fd24ad58d788ca1fa2fddb9084197cfc526386d223f88be38ec2e1820c419cb3dad133c158d4b004ae0943b790f0719b40e58007ba730346943884ddc36467e876ca7a3afb0e5a10127d18e3080edc18f9fbe590457352dca398b61eff93eec745c0e49de20bba1dd77df6de86052ffff41247d
    e2 = 0x10001
    pbits = 512
    for i in range(0,4095):
      p4 = 0x636c1b2209b27268ad05ff5d64802c40d509cefccd92953227264dab0f27187dea4fdf000
      p4 = p4 + int(hex(i),16)
      kbits = pbits - p4.nbits() 
      p4 = p4 << kbits 
      PR.<x> = PolynomialRing(Zmod(n))
      f = x + p4
      roots = f.small_roots(X=2^kbits, beta=0.4) 
      if roots: 
        p = p4+int(roots[0])
        assert n % p == 0
        q = n/int(p)
        phin = (p-1)*(q-1)
        d = inverse_mod(e2,phin)
        print(d)
        cipher = 0x56d1b214082fd508567e0a4e101dcaa4f3edf262d7330cae4d75d94b874f53dfe3c9ba66d62a41b7e9331e67ae6907e3c028701e53555fea0832b2908471d04ceb98dbedf576a504902d50c3c32050fa036573de4f466f9c5de6b6bd4ad2f96bd6cd235a62c6c9555eb5ecf5b793b514f60d3e75a8307983c0f1aab746477a7b
        flag = pow(cipher,d,n)
        flag = hex(int(flag))[2:-1]
        print (binascii.unhexlify(flag))
    #https://sagecell.sagemath.org/
    ```

    
