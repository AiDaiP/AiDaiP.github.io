#  RSA从入门到入土

* #### 数学知识

  * ##### 互质

    如果两个或两个以上的整数的最大公约数是 1，则称它们为互质

    任意两个质数构成互质关系

  * ##### 同余

    给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，那么就称整数a与b对模m同余，记作$$a≡b(mod\ m)$$

  * ##### 模反元素

    如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。这时，b就叫做a对模数n的“模反元素” 。 

    即 $$ab≡1 (mod\  n)​$$

  * ##### 扩展欧几里得算法

    扩展欧几里德算法是用来在已知a, b时，求解一组x，y，使它们满足贝祖等式 $$ax+by = gcd(a, b)$$

    

  * ##### 欧拉函数

    对正整数n，欧拉函数φ(n)是小于或等于n的正整数中与n互质的数的数目

    欧拉函数是积性函数，若m,n互质，则 $$φ(mn)=φ(m)φ(n)$$

    若n为质数，则 $$φ(n)=n-1$$

    

  * ##### 欧拉定理

    若n,a为正整数，且n,a互质，则 $$a^{φ(n)}=1\ (mod\ n)$$

    

* #### 密钥生成

  1. 随机选择两个不相等的质数p、q

     $$p=14214677$$

     $$q=15733001$$

     

  2. 计算p、q乘积n

     $$n=p× q=223639527455677$$

  3. 计算φ(n)

     $$φ(n)=(p-1)(q-1)=14214676×15733000=‭223639497508000‬$$

  4. 随机选择一个整数$$e$$  ($$1<e<φ(n)$$且e与φ(n) 互质)

     $$e=30001$$

  5. 计算e对于φ(n)的模反元素d

     $$ed≡1\ (mod\ φ(n))$$ 

     变形，得到一个二元一次方程

     $$ed-kφ(n)=1$$

     $$30001d-‭223639497508000k=1$$

     可以看作

     $$30001x+223639497508000y=gcd(30001,223639497508000k)=1$$

     使用扩展欧几里得算法求解，得到

     $$(x,y)=(223639497508000,-30000)$$

     $$d=223639497508000$$

  6. 将n和e封装成公钥，n和d封装成私钥

     公钥$$(223639527455677,30001)$$

     私钥$$(223639527455677,223639497508000)$$

     

     

* #### 加密与解密

  * 公钥加密

    $$m^e≡c (mod\ n)$$ 

    m为明文，c为密文，加密就是计算c

    加密“flag”

    m=0x666c6167=‭1718378855‬

    $$‭1718378855^{30001} ≡c (mod\ 223639527455677)$$

    解得$$c=191215680523649$$

    

  * 私钥解密

    $$c^d≡m\ (mod\ n)$$ 

    $$191215680523649^{223639497508000}≡m\ (mod\ 223639527455677)$$

    解得$$m=‭1718378855$$

    转化为字符串得到“flag”

    

    解密方法的证明

    证：$$c^d≡m\ (mod\ n)$$ 

    由加密规则可得

    $$c=m^e-kn$$

    代入，即证：

    $$(m^e-kn)^d≡ m\ (mod\ n)$$

    左边展开后除了第一项，其余项均模n余0，即证：

    $$m^{ed}≡m\ (mod\ n)$$ 

    d为e对于φ(n)的模反元素，所以

    $$ed=hφ(n)+1$$ 

    代入，即证：

    $$m^{hφ(n)+1}≡m\ (mod\ n)$$

    1. m、n互质

       根据欧拉定理可得

        $$m^{φ(n)}=1\ (mod\ n)$$

       所以

       $$m(m^{φ(n)})^h=m\ (mod\ n)$$

       即

       $$m^{hφ(n)+1}≡m\ (mod\ n)$$

       

    2. m、n不互质

       n的因数为1，n，p，q，若m、n不互质，必然有$$m=kp$$ 或 $$m=kq$$

       不妨设 $$m=kp$$

       $$m<n$$ 所以 $$k<q$$，k与q一定互质，kp和q互质，所以

       $$(kp)^{φ(q)}≡1\ (mod\ q)​$$

       即

       $$(kp)^{q-1}≡1\ (mod\ q)$$

       所以

       $$[kp^{(q-1)}]^{h(p-1)}kp≡kp\ (mod\ q)​$$

       即

       $$(kp)^{ed}≡kp\ (mod\ q)$$

       $$(kp)^{ed}=tq+kp$$

       $$(kp)^{ed}$$和$$kp$$能被p整除，所以t一定能被p整除

       设$$t=ap$$

       $$(kp)^{ed}=apq+kp$$

       即

       $$m^{ed}=an+kp$$

       所以

       $$m^{ed}≡m\ (mod\ n)​$$ 

       

* #### 快速幂取模

  * ##### 同余定理

    ```
    (a +/- b) % c = (a % c +/- b % c) % c 
    
    (a * b) % c = (a % c) * (b % c) % c 
    
    ab % c = (a % c)b % c
    ```

   * ##### 代码实现

     ```python
     def quick_mod(a,b,c):
         ans = 1
         t = a % c
         while b:
             if b & 1:
                 ans = (ans * t) % c
             t = (t * t) % c
             b >>= 1
         return ans
     ```

     

* #### 小公钥指数攻击

  * ##### 条件

    e特别小，如e = 3

  * ##### 原理

    $$c≡m^{e}\ (mod\ n)​$$ 

    $$ m^{e} = c + kn ​$$

    $$ m = (c + kn)^{1/e} ​$$

    枚举k，开e次根，直到开出整数

    **[Jarvis-OJ-extremely-hard-rsa](https://aidaip.github.io/example/2019-02-12-Jarvis-OJ-%E4%BB%8E%E6%89%93%E5%BC%80%E7%BD%91%E7%AB%99%E5%88%B0%E5%8E%BB%E4%B8%96/#extremely-hard-rsa)**

    

* #### Rabin算法

  * ##### 条件

    n = 2

  * ##### 原理

    $$c=m^{2}\ mod\ n$$ 

    $$m_p =\sqrt{c}\ mod\ p $$

    $$m_q =\sqrt{c}\ mod\ q $$

    

    若$$p≡q≡3\ (mod\ 4)​$$

    $$m_p = c^{1/4(p+1)}\ mod\ p​$$

    $$m_q = c^{1/4(q+1)}\ mod\ q$$

    $$y_pp+y_qq=1$$

    $$gcdext(p,q)$$解出$$y_p,y_q$$

    解出四个明文

    $$a = (y_ppm_q+y_qq_mp)\ mod\ n​$$

    $$ b = n -a​$$

    $$c = (y_ppm_q-y_qq_mp)\ mod\ n$$

    $$d = n - c$$

    **[Jarvis-OJ-hard-rsa](https://aidaip.github.io/example/2019-02-12-Jarvis-OJ-%E4%BB%8E%E6%89%93%E5%BC%80%E7%BD%91%E7%AB%99%E5%88%B0%E5%8E%BB%E4%B8%96/#hard-rsa)**

* #### 共模攻击

  * ##### 条件

    用相同的n不同的e对明文ｍ加密

  * ##### 原理

    $$c_1 ≡ m^{e_1} (mod\ n)​$$

    $$c_2 ≡ m^{e_2} (mod\ n)​$$

    $$gcd(e_1,e_2) = 1$$

    存在$$s_1,s_2​$$使$$s_1e_1+s_2e_2 = 1​$$

    $$c_1≡m^{e_1}\ (mod\ n)​$$ 

    $$c_2≡m^{e_2}\ (mod\ n)​$$ 

    所以

    $$c_1^{s_1}c_2^{s_2}≡(m^{e_1})^{s_1}(m^{e_2})^{s_2}\ (mod\ n)​$$ 

    $$c_1^{s_1}c_2^{s_2}≡m^{e_1s_1+e_2s_2}\ (mod\ n)​$$ 

    $$c_1^{s_1}c_2^{s_2}≡m\ (mod\ n)$$ 

    **[Jarvis-OJ-very-hard-rsa](https://aidaip.github.io/example/2019-02-12-Jarvis-OJ-%E4%BB%8E%E6%89%93%E5%BC%80%E7%BD%91%E7%AB%99%E5%88%B0%E5%8E%BB%E4%B8%96/#very-hard-rsa)**

* #### Wiener's attack

  * ##### 条件

    $$d<1/3N^{1/4}$$

  * ##### 原理

    [Wiener's attack](https://en.wikipedia.org/wiki/Wiener%27s_attack)

    [rsa-wiener-attack](https://github.com/pablocelayes/rsa-wiener-attack)

  

* #### Factoring with High Bits Known

  * ##### 条件

    已知N的一个因子的较高位

    ![coppersmith1](https://raw.githubusercontent.com/AiDaiP/AiDaiP.github.io/master/images/rsa/coppersmith1.png)

    ```
    p.bit_length() == 1024 ,p的高位需已知约576位
    p.bit_length() == 512 ,p的高位需已知约288位
    ```

  * 例子

    ```sage
    '''
    n = 110884890902749085253001083431222443088115610795940152564793628519927092107501946446399003764508722709710121804620193329162066855289179887539537634989483300155392790067446377224025966917227342075570751172611456818461296838516185655681858001119900898375522640670694604696426035782721144065487316221499661637517
    e = 65537
    c = 56d1b214082fd508567e0a4e101dcaa4f3edf262d7330cae4d75d94b874f53dfe3c9ba66d62a41b7e9331e67ae6907e3c028701e53555fea0832b2908471d04ceb98dbedf576a504902d50c3c32050fa036573de4f466f9c5de6b6bd4ad2f96bd6cd235a62c6c9555eb5ecf5b793b514f60d3e75a8307983c0f1aab746477a7b
    front = 754471047130831460574350468751127056146566410666010180184022324900851348720910487519
    backLength = 512 - front.bit_length()
    '''
    
    import binascii
    n=110884890902749085253001083431222443088115610795940152564793628519927092107501946446399003764508722709710121804620193329162066855289179887539537634989483300155392790067446377224025966917227342075570751172611456818461296838516185655681858001119900898375522640670694604696426035782721144065487316221499661637517
    cipher = 0x56c5afbc956157241f2d4ea90fd24ad58d788ca1fa2fddb9084197cfc526386d223f88be38ec2e1820c419cb3dad133c158d4b004ae0943b790f0719b40e58007ba730346943884ddc36467e876ca7a3afb0e5a10127d18e3080edc18f9fbe590457352dca398b61eff93eec745c0e49de20bba1dd77df6de86052ffff41247d
    e2 = 0x10001
    pbits = 512
    for i in range(0,4095):
      p4 = 0x636c1b2209b27268ad05ff5d64802c40d509cefccd92953227264dab0f27187dea4fdf000
      p4 = p4 + int(hex(i),16)
      kbits = pbits - p4.nbits() 
      p4 = p4 << kbits 
      PR.<x> = PolynomialRing(Zmod(n))
      f = x + p4
      roots = f.small_roots(X=2^kbits, beta=0.4) 
      if roots: 
        p = p4+int(roots[0])
        assert n % p == 0
        q = n/int(p)
        phin = (p-1)*(q-1)
        d = inverse_mod(e2,phin)
        print(d)
        cipher = 0x56d1b214082fd508567e0a4e101dcaa4f3edf262d7330cae4d75d94b874f53dfe3c9ba66d62a41b7e9331e67ae6907e3c028701e53555fea0832b2908471d04ceb98dbedf576a504902d50c3c32050fa036573de4f466f9c5de6b6bd4ad2f96bd6cd235a62c6c9555eb5ecf5b793b514f60d3e75a8307983c0f1aab746477a7b
        flag = pow(cipher,d,n)
        flag = hex(int(flag))[2:-1]
        print (binascii.unhexlify(flag))
    #https://sagecell.sagemath.org/
    ```

* #### Known High Bits Message Attack

  * ##### 例子

    ```sage
    /*
    [+]n=0x7c3139d3be9a691abdf3ff49c712fcb84ba39bbd2189bb98d04e04d2d7cc086c9d31b06fdf828aaeeb3765e1ab8ea41a3f1b8c73b80a498f1e2eaad42a1ac7b8e54e705cd1e3e4a39940f9bdcd16d4b42ab71a826955cc78450d6915663c82ae80fd2f64b7e3a70f2b188b85a738759eeb0688dfa22525bbbe92d7934763445L
    [+]e=3
    [+]m=random.getrandbits(512)
    [+]c=pow(m,e,n)=0x20084d9c4fa81d903437a9fabea4a2ad025a00ddc961e4fcd0f52ff9ec750702c109ce0188ae96e540a5c3dcf55013ced9ee37ad9547240fc8773f81fbb509b0b8ab24ed0288a6e1f997b5c0b196236bc8da2df9cce77c559492963eeafbbe4f5a9cb18098bfac87a1e179b26f60948fb72327acc0675890009a04697b76073L
    [+]((m>>72)<<72)=0xb90f972f73ebb3952b3a8e50233f783732478d874795b44c33f685caf7637f4cd0c90cf3a599e1a01e84a28459220b31a490fd1892df58000000000000000000L
    */
    
    import time
    def matrix_overview(BB, bound):
        for ii in range(BB.dimensions()[0]):
            a = ('%02d ' % ii)
            for jj in range(BB.dimensions()[1]):
                a += '0' if BB[ii,jj] == 0 else 'X'
                a += ' '
            if BB[ii, ii] >= bound:
                a += '~'
            print a
    def coppersmith_howgrave_univariate(pol, modulus, beta, mm, tt, XX):
    
        dd = pol.degree()
        nn = dd * mm + tt
    
        if not 0 < beta <= 1:
            raise ValueError("beta should belongs in (0, 1]")
    
        if not pol.is_monic():
            raise ArithmeticError("Polynomial must be monic.")
       
        polZ = pol.change_ring(ZZ)
        x = polZ.parent().gen()
    
        # compute polynomials
        gg = []
        for ii in range(mm):
            for jj in range(dd):
                gg.append((x * XX)**jj * modulus**(mm - ii) * polZ(x * XX)**ii)
        for ii in range(tt):
            gg.append((x * XX)**ii * polZ(x * XX)**mm)
    
        BB = Matrix(ZZ, nn)
    
        for ii in range(nn):
            for jj in range(ii+1):
                BB[ii, jj] = gg[ii][jj]
    
        # display basis matrix
        if debug:
            matrix_overview(BB, modulus^mm)
    
        # LLL
        BB = BB.LLL()
    
        # transform shortest vector in polynomial    
        new_pol = 0
        for ii in range(nn):
            new_pol += x**ii * BB[0, ii] / XX**ii
    
        # factor polynomial
        potential_roots = new_pol.roots()
        print "potential roots:", potential_roots
    
        # test roots
        roots = []
        for root in potential_roots:
            if root[0].is_integer():
                result = polZ(ZZ(root[0]))
                if gcd(modulus, result) >= modulus^beta:
                    roots.append(ZZ(root[0]))
        return roots
    
    
    # RSA gen options (for the demo)
    length_N = 1024  # size of the modulus
    Kbits = 72      # size of the root
    e = 3
    N = 0x7c3139d3be9a691abdf3ff49c712fcb84ba39bbd2189bb98d04e04d2d7cc086c9d31b06fdf828aaeeb3765e1ab8ea41a3f1b8c73b80a498f1e2eaad42a1ac7b8e54e705cd1e3e4a39940f9bdcd16d4b42ab71a826955cc78450d6915663c82ae80fd2f64b7e3a70f2b188b85a738759eeb0688dfa22525bbbe92d7934763445L
    ZmodN = Zmod(N);
    
    C = 0x20084d9c4fa81d903437a9fabea4a2ad025a00ddc961e4fcd0f52ff9ec750702c109ce0188ae96e540a5c3dcf55013ced9ee37ad9547240fc8773f81fbb509b0b8ab24ed0288a6e1f997b5c0b196236bc8da2df9cce77c559492963eeafbbe4f5a9cb18098bfac87a1e179b26f60948fb72327acc0675890009a04697b76073L
    msg = 0xb90f972f73ebb3952b3a8e50233f783732478d874795b44c33f685caf7637f4cd0c90cf3a599e1a01e84a28459220b31a490fd1892df58000000000000000000
    P.<x> = PolynomialRing(ZmodN) #, implementation='NTL')
    pol = (msg + x)^e - C
    dd = pol.degree()
    
    # Tweak those
    beta = 1                                # b = N
    epsilon = beta / 7                      # <= beta / 7
    mm = ceil(beta**2 / (dd * epsilon))     # optimized value
    tt = floor(dd * mm * ((1/beta) - 1))    # optimized value
    XX = ceil(N**((beta**2/dd) - epsilon))  # optimized value
    
    # Coppersmith
    start_time = time.time()
    roots = coppersmith_howgrave_univariate(pol, N, beta, mm, tt, XX)
    
    # output
    print "\n# Solutions"
    print "we found:", str(roots)
    print("in: %s seconds " % (time.time() - start_time))
    print "\n"
    
    ```

  

* #### 部分私钥泄露

  * ##### 例子

    ```sage
    /*
    [+]n=0x291b24eae63660849a91b7122663814918ae91d62e3431163c4f47ecdbf92c59c9c430bbcc9443e4ff3dedbe60b1c06f383771bf628cdd36e649aa0c96db4addac4885071b651d2b1ae4e131ae3c115f1a59b828999ca7af8f235b75ad5b757680249eaa9b531ec1edbf9204417f17df08ec550893ed36523fcfef7fb4b2415dL
    [+]e=3
    [+]m=random.getrandbits(512)
    [+]c=pow(m,e,n)=0x623dc16f9047da92278d94fe3cabbd89db4f8c4c612ac55a439df31e368133d697cb08a571e2aad2a194800a433bc00940967441bb7e0d30bfc0599c55aeefc4af8be67ffaac307b65a2096863ca87c6aad615535814758212baae7328ac1ae9bce9f39a52456852c4c0b9779edbb19016872f516e2be9fab463f3b405e25beL
    [+]d=invmod(e,(p-1)*(q-1))
    [+]d&((1<<512)-1)=0x91d03d35338acebcf703991efd4b3f9c88e2f022568c31a410a33062d3e3e24571dc3537e21741e6b1c9eba127db0a768842d79a3197dca5b86e2cd509cd3b93L
    */
    
    known_bits = 512
    e = 3
    X = var('X')
    N=0x291b24eae63660849a91b7122663814918ae91d62e3431163c4f47ecdbf92c59c9c430bbcc9443e4ff3dedbe60b1c06f383771bf628cdd36e649aa0c96db4addac4885071b651d2b1ae4e131ae3c115f1a59b828999ca7af8f235b75ad5b757680249eaa9b531ec1edbf9204417f17df08ec550893ed36523fcfef7fb4b2415d
    d0 = 0x91d03d35338acebcf703991efd4b3f9c88e2f022568c31a410a33062d3e3e24571dc3537e21741e6b1c9eba127db0a768842d79a3197dca5b86e2cd509cd3b93
    P.<x> = PolynomialRing(Zmod(N))
    for k in xrange(1, e+1):
        results = solve_mod([e * d0 * X - k * X * (N - X + 1) + k * N == X], 2 ** 512)
    
        for m in results:
            f = x * 2 ** known_bits + ZZ(m[0])
            f = f.monic()
            roots = f.small_roots(X = 1, beta=0.3)
    
            if roots:
                x0 = roots[0]
                p = gcd(2 ** known_bits * x0 + ZZ(m[0]), N)
                print '[+] Found factorization!'
                print 'p =', ZZ(p)
                print 'q =', N / ZZ(p)
                break
    n=0x291b24eae63660849a91b7122663814918ae91d62e3431163c4f47ecdbf92c59c9c430bbcc9443e4ff3dedbe60b1c06f383771bf628cdd36e649aa0c96db4addac4885071b651d2b1ae4e131ae3c115f1a59b828999ca7af8f235b75ad5b757680249eaa9b531ec1edbf9204417f17df08ec550893ed36523fcfef7fb4b2415d
    p = 4369408607185874842987791687972458181281635894126489505104950532427588844072160412371716367300194382551703650763840526184308340422066926730909955032516327
    q = 6606303039610996668393006981258443682930645126368365403476569537191826726070101133886617447839914797821331788273937106747740172175833966059802001454391579
    e = 3
    phin = (p-1)*(q-1)
    d = inverse_mod(e,phin)
    cipher = 0x623dc16f9047da92278d94fe3cabbd89db4f8c4c612ac55a439df31e368133d697cb08a571e2aad2a194800a433bc00940967441bb7e0d30bfc0599c55aeefc4af8be67ffaac307b65a2096863ca87c6aad615535814758212baae7328ac1ae9bce9f39a52456852c4c0b9779edbb19016872f516e2be9fab463f3b405e25be
    print(d)
    flag = pow(cipher,d,n)
    flag = hex(int(flag))[2:-1]
    print(flag)
    
    ```

  

* #### Basic Broadcast Attack

  * ##### 例子

    ```python
    /*
    [+]e=3
    [+]m=random.getrandbits(512)
    [+]n1=0x20833e893b24b5240f940bfddd7ee7e4877c6c09858f74e6b9a30e2f6b4ddcc79f4aeb74818a210481bc0cede15edf5a78f3e976690fe2471ef27e3a176d5cbf01a378be85f3ad560fa0992355c636144f5157cc196a027d87e250315f83346a19b735ec151895f42c6300a87d8345c3e98d2489fae8e6a63f5f776af8e32547L
    [+]c1=pow(m,e,n1)=0x19da41d645595b0d29f9b73001e6aff709d638965bfd979bce43199d7ac8c48551ff5d833ad02fb75e4d5c9cb54ee3426d8aee37b74997d546b2fc7a98f290fc24de72cb6ac037fb2ba6d6e648e4557cfcae97ac2e38b66565a46802ca93b9b2f51486b9b20199fe92094e49372032432c38afc1290da70c06424f6d2d90d25fL
    [+]n2=0x15a07bcc2a00701d9e3900df672c562335d402cbba28f2e5d2daf8652db264e6812370e89d94f4e99c1402c7c897d52d9c55cdcc2d5da6f5a27f76c418ec907ed269a17a2d771b5ef54f9b44ed2406a7bb5a0aa5a104777b62f76d763b545c324f13cb33e656529edcc23be550af58ca905f777991d41f1521b3f8ffdad9370fL
    [+]c2=pow(m,e,n2)=0x70ec72eb18272633ee5e92baa8276bf8609ffb3645a0be15b0d0143ae04a3d2861f69e8329f59628d1836eaeebc6cb4ac26dc373c7de240ccc8d069448f6cadabfe7134cd495fa278cfcdda89aaf137e306621f92bc78feeb687ec1dced4856c4fc6cdc77b5db239dbd1f4d677137546a0d8ca532093f171c2f7da1278eeba9L
    [+]n3=0x1a70d5223cc981967a5d3f29072804804eb3c49a7375854ff63b438485cbc2740a94d52c5079eed1fccb4d05689c8cec6a2fe1559e5106cebe080621aa953848aae939308c5f06d3cd5b9699c29abaf350605efdd62f2fd324456b7f6c42fd59e069ead9040de68717444415999fe8e0ce2e23fc733988704e3179f621587c63L
    [+]c3=pow(m,e,n3)=0x105ee63d6a1db25bf85c419f827c2f4bc7d460033b10fd8a3d63ecdb8bcc82dcc84a500b94ab4b4aff7ba1db514cfcec5c70a06980d9fe7be6a4a74d7dcee16c5bb40f2ba32d5f3bf889bf1eb563018c066466b47883d90f8da684f1bb030f8834f6dd9e70b055d7a090696112e9f38f7d90cf4eb037a27e7247eeee4b55cd97L
    */
    
    import gmpy2
    dic = [{"c": 0x105ee63d6a1db25bf85c419f827c2f4bc7d460033b10fd8a3d63ecdb8bcc82dcc84a500b94ab4b4aff7ba1db514cfcec5c70a06980d9fe7be6a4a74d7dcee16c5bb40f2ba32d5f3bf889bf1eb563018c066466b47883d90f8da684f1bb030f8834f6dd9e70b055d7a090696112e9f38f7d90cf4eb037a27e7247eeee4b55cd97, "e": 3, "n": 0x1a70d5223cc981967a5d3f29072804804eb3c49a7375854ff63b438485cbc2740a94d52c5079eed1fccb4d05689c8cec6a2fe1559e5106cebe080621aa953848aae939308c5f06d3cd5b9699c29abaf350605efdd62f2fd324456b7f6c42fd59e069ead9040de68717444415999fe8e0ce2e23fc733988704e3179f621587c63},
    {"c": 0x70ec72eb18272633ee5e92baa8276bf8609ffb3645a0be15b0d0143ae04a3d2861f69e8329f59628d1836eaeebc6cb4ac26dc373c7de240ccc8d069448f6cadabfe7134cd495fa278cfcdda89aaf137e306621f92bc78feeb687ec1dced4856c4fc6cdc77b5db239dbd1f4d677137546a0d8ca532093f171c2f7da1278eeba9, "e": 3, "n": 0x15a07bcc2a00701d9e3900df672c562335d402cbba28f2e5d2daf8652db264e6812370e89d94f4e99c1402c7c897d52d9c55cdcc2d5da6f5a27f76c418ec907ed269a17a2d771b5ef54f9b44ed2406a7bb5a0aa5a104777b62f76d763b545c324f13cb33e656529edcc23be550af58ca905f777991d41f1521b3f8ffdad9370f},
    {"c": 0x19da41d645595b0d29f9b73001e6aff709d638965bfd979bce43199d7ac8c48551ff5d833ad02fb75e4d5c9cb54ee3426d8aee37b74997d546b2fc7a98f290fc24de72cb6ac037fb2ba6d6e648e4557cfcae97ac2e38b66565a46802ca93b9b2f51486b9b20199fe92094e49372032432c38afc1290da70c06424f6d2d90d25f, "e": 3, "n": 0x20833e893b24b5240f940bfddd7ee7e4877c6c09858f74e6b9a30e2f6b4ddcc79f4aeb74818a210481bc0cede15edf5a78f3e976690fe2471ef27e3a176d5cbf01a378be85f3ad560fa0992355c636144f5157cc196a027d87e250315f83346a19b735ec151895f42c6300a87d8345c3e98d2489fae8e6a63f5f776af8e32547}]
    n = []
    C = []
    for i in dic:
        n.append(i["n"])
        C.append(i["c"])
    
    N = 1
    for i in n:
        N *= i
    
    Ni = []
    for i in n:
        Ni.append(N / i)
    
    T = []
    for i in xrange(3):
        T.append(long(gmpy2.invert(Ni[i], n[i])))
    
    X = 0
    for i in xrange(3):
        X += C[i] * Ni[i] * T[i]
    
    m3 = X % N
    m = gmpy2.iroot(m3, 3)
    print(m)
    
    ```

  

* #### Coppersmith’s short-pad attack

  * ##### 例子

    ```
    [+]n=0xc9f2c02d0ce22b192b5a046f8311b3eb470394ef228bbe8bc31f2939e3d7472a62eea2468c06b7d7de3a155a2e5a10c98143ede2fdf2f60fe5d65c9ba9fa26f5f7d05591201c76765599fb35f13e00a5b089fd4215c57b1453aaefc911a73c9f39003153af5e4a2e882a1c6c02d0024a6b0dede6c159a65b0bfe5c57b616127L
    [+]e=3
    [+]m=random.getrandbits(512)
    [+]c=pow(m,e,n)=0xb6046b56183fcc80d8a7c5dbc1f39176e736e2054255002abe1947a6e51fb7c37bdd689235613aec0e2a2651fade4837b968d4d6396b908a407f35e742065a773499f3bcd6111f2a1d8b65a3c79c9d3b20d681b9bf8cb2f26d2c528bca82e76d45ec734647cb13ca1a327e88173a64839bd4d8e576427600c86e7bc7224832cL
    [+]x=pow(m+1,e,n)=0xb590cc6da005f5bae916d26dca52f3f8e4c6c77d3d24df9f1f6e4e1ef1e58dc3b2bb0571810f5f27b019be2a768a392057c83006cbb12363b9661089d3fae650017c64d218ebe2b48b2ae91128d7613e6e51fabb94e7aaaba01d711d40ddac122683060ca5416ff0a00fa7f043f834d3989f8240b677a0cdda107832abe56c4L
    
    import gmpy2
    def getM2(a,b,c1,c2,n):
        a3 = pow(a,3,n)
        b3 = pow(b,3,n)
        first = c1-a3*c2+2*b3
        first = first % n
        second = 3*b*(a3*c2-b3)
        second = second % n
        third = second*gmpy2.invert(first,n)
        third = third % n
        fourth = (third+b)*gmpy2.invert(a,n)
        return fourth % n
    n=0xc9f2c02d0ce22b192b5a046f8311b3eb470394ef228bbe8bc31f2939e3d7472a62eea2468c06b7d7de3a155a2e5a10c98143ede2fdf2f60fe5d65c9ba9fa26f5f7d05591201c76765599fb35f13e00a5b089fd4215c57b1453aaefc911a73c9f39003153af5e4a2e882a1c6c02d0024a6b0dede6c159a65b0bfe5c57b616127L
    e=3
    c1=0xb6046b56183fcc80d8a7c5dbc1f39176e736e2054255002abe1947a6e51fb7c37bdd689235613aec0e2a2651fade4837b968d4d6396b908a407f35e742065a773499f3bcd6111f2a1d8b65a3c79c9d3b20d681b9bf8cb2f26d2c528bca82e76d45ec734647cb13ca1a327e88173a64839bd4d8e576427600c86e7bc7224832cL
    c2=0xb590cc6da005f5bae916d26dca52f3f8e4c6c77d3d24df9f1f6e4e1ef1e58dc3b2bb0571810f5f27b019be2a768a392057c83006cbb12363b9661089d3fae650017c64d218ebe2b48b2ae91128d7613e6e51fabb94e7aaaba01d711d40ddac122683060ca5416ff0a00fa7f043f834d3989f8240b677a0cdda107832abe56c4L
    padding1 = 0
    padding2 = 1
    m = getM2(1,padding1-padding2,c1,c2,n)-padding2
    print(hex(m))
    
    ```

  

* #### Boneh and Durfee attack

  * ##### 例子

    ```sage
    /*
    [+]n=0xbadd260d14ea665b62e7d2e634f20a6382ac369cd44017305b69cf3a2694667ee651acded7085e0757d169b090f29f3f86fec255746674ffa8a6a3e1c9e1861003eb39f82cf74d84cc18e345f60865f998b33fc182a1a4ffa71f5ae48a1b5cb4c5f154b0997dc9b001e441815ce59c6c825f064fdca678858758dc2cebbc4d27L
    [+]d=random.getrandbits(1024*0.270)
    [+]e=invmod(d,phin)
    [+]hex(e)=0x11722b54dd6f3ad9ce81da6f6ecb0acaf2cbc3885841d08b32abc0672d1a7293f9856db8f9407dc05f6f373a2d9246752a7cc7b1b6923f1827adfaeefc811e6e5989cce9f00897cfc1fc57987cce4862b5343bc8e91ddf2bd9e23aea9316a69f28f407cfe324d546a7dde13eb0bd052f694aefe8ec0f5298800277dbab4a33bbL
    [+]m=random.getrandbits(512)
    [+]c=pow(m,e,n)=0xe3505f41ec936cf6bd8ae344bfec85746dc7d87a5943b3a7136482dd7b980f68f52c887585d1c7ca099310c4da2f70d4d5345d3641428797030177da6cc0d41e7b28d0abce694157c611697df8d0add3d900c00f778ac3428f341f47ecc4d868c6c5de0724b0c3403296d84f26736aa66f7905d498fa1862ca59e97f8f866cL
    */
    
    import time
    
    strict = False
    
    helpful_only = True
    dimension_min = 7 # stop removing if lattice reaches that dimension
    
    def helpful_vectors(BB, modulus):
        nothelpful = 0
        for ii in range(BB.dimensions()[0]):
            if BB[ii,ii] >= modulus:
                nothelpful += 1
    
        print nothelpful, "/", BB.dimensions()[0], " vectors are not helpful"
    
    # display matrix picture with 0 and X
    def matrix_overview(BB, bound):
        for ii in range(BB.dimensions()[0]):
            a = ('%02d ' % ii)
            for jj in range(BB.dimensions()[1]):
                a += '0' if BB[ii,jj] == 0 else 'X'
                if BB.dimensions()[0] < 60:
                    a += ' '
            if BB[ii, ii] >= bound:
                a += '~'
            print a
    
    # tries to remove unhelpful vectors
    # we start at current = n-1 (last vector)
    def remove_unhelpful(BB, monomials, bound, current):
        # end of our recursive function
        if current == -1 or BB.dimensions()[0] <= dimension_min:
            return BB
    
        # we start by checking from the end
        for ii in range(current, -1, -1):
            # if it is unhelpful:
            if BB[ii, ii] >= bound:
                affected_vectors = 0
                affected_vector_index = 0
                # let's check if it affects other vectors
                for jj in range(ii + 1, BB.dimensions()[0]):
                    # if another vector is affected:
                    # we increase the count
                    if BB[jj, ii] != 0:
                        affected_vectors += 1
                        affected_vector_index = jj
    
                # level:0
                # if no other vectors end up affected
                # we remove it
                if affected_vectors == 0:
                    print "* removing unhelpful vector", ii
                    BB = BB.delete_columns([ii])
                    BB = BB.delete_rows([ii])
                    monomials.pop(ii)
                    BB = remove_unhelpful(BB, monomials, bound, ii-1)
                    return BB
    
                # level:1
                # if just one was affected we check
                # if it is affecting someone else
                elif affected_vectors == 1:
                    affected_deeper = True
                    for kk in range(affected_vector_index + 1, BB.dimensions()[0]):
                        # if it is affecting even one vector
                        # we give up on this one
                        if BB[kk, affected_vector_index] != 0:
                            affected_deeper = False
                    # remove both it if no other vector was affected and
                    # this helpful vector is not helpful enough
                    # compared to our unhelpful one
                    if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) < abs(bound - BB[ii, ii]):
                        print "* removing unhelpful vectors", ii, "and", affected_vector_index
                        BB = BB.delete_columns([affected_vector_index, ii])
                        BB = BB.delete_rows([affected_vector_index, ii])
                        monomials.pop(affected_vector_index)
                        monomials.pop(ii)
                        BB = remove_unhelpful(BB, monomials, bound, ii-1)
                        return BB
        # nothing happened
        return BB
    
    """ 
    Returns:
    * 0,0   if it fails
    * -1,-1 if `strict=true`, and determinant doesn't bound
    * x0,y0 the solutions of `pol`
    """
    def boneh_durfee(pol, modulus, mm, tt, XX, YY):
        """
        Boneh and Durfee revisited by Herrmann and May
        
        finds a solution if:
        * d < N^delta
        * |x| < e^delta
        * |y| < e^0.5
        whenever delta < 1 - sqrt(2)/2 ~ 0.292
        """
    
        # substitution (Herrman and May)
        PR.<u, x, y> = PolynomialRing(ZZ)
        Q = PR.quotient(x*y + 1 - u) # u = xy + 1
        polZ = Q(pol).lift()
    
        UU = XX*YY + 1
    
        # x-shifts
        gg = []
        for kk in range(mm + 1):
            for ii in range(mm - kk + 1):
                xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk
                gg.append(xshift)
        gg.sort()
    
        # x-shifts list of monomials
        monomials = []
        for polynomial in gg:
            for monomial in polynomial.monomials():
                if monomial not in monomials:
                    monomials.append(monomial)
        monomials.sort()
        
        # y-shifts (selected by Herrman and May)
        for jj in range(1, tt + 1):
            for kk in range(floor(mm/tt) * jj, mm + 1):
                yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk)
                yshift = Q(yshift).lift()
                gg.append(yshift) # substitution
        
        # y-shifts list of monomials
        for jj in range(1, tt + 1):
            for kk in range(floor(mm/tt) * jj, mm + 1):
                monomials.append(u^kk * y^jj)
    
        # construct lattice B
        nn = len(monomials)
        BB = Matrix(ZZ, nn)
        for ii in range(nn):
            BB[ii, 0] = gg[ii](0, 0, 0)
            for jj in range(1, ii + 1):
                if monomials[jj] in gg[ii].monomials():
                    BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY)
    
        # Prototype to reduce the lattice
        if helpful_only:
            # automatically remove
            BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1)
            # reset dimension
            nn = BB.dimensions()[0]
            if nn == 0:
                print "failure"
                return 0,0
    
        # check if vectors are helpful
        if debug:
            helpful_vectors(BB, modulus^mm)
        
        # check if determinant is correctly bounded
        det = BB.det()
        bound = modulus^(mm*nn)
        if det >= bound:
            print "We do not have det < bound. Solutions might not be found."
            print "Try with highers m and t."
            if debug:
                diff = (log(det) - log(bound)) / log(2)
                print "size det(L) - size e^(m*n) = ", floor(diff)
            if strict:
                return -1, -1
        else:
            print "det(L) < e^(m*n) (good! If a solution exists < N^delta, it will be found)"
    
        # display the lattice basis
        if debug:
            matrix_overview(BB, modulus^mm)
    
        # LLL
        if debug:
            print "optimizing basis of the lattice via LLL, this can take a long time"
    
        BB = BB.LLL()
    
        if debug:
            print "LLL is done!"
    
        # transform vector i & j -> polynomials 1 & 2
        if debug:
            print "looking for independent vectors in the lattice"
        found_polynomials = False
        
        for pol1_idx in range(nn - 1):
            for pol2_idx in range(pol1_idx + 1, nn):
                # for i and j, create the two polynomials
                PR.<w,z> = PolynomialRing(ZZ)
                pol1 = pol2 = 0
                for jj in range(nn):
                    pol1 += monomials[jj](w*z+1,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY)
                    pol2 += monomials[jj](w*z+1,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY)
    
                # resultant
                PR.<q> = PolynomialRing(ZZ)
                rr = pol1.resultant(pol2)
    
                # are these good polynomials?
                if rr.is_zero() or rr.monomials() == [1]:
                    continue
                else:
                    print "found them, using vectors", pol1_idx, "and", pol2_idx
                    found_polynomials = True
                    break
            if found_polynomials:
                break
    
        if not found_polynomials:
            print "no independant vectors could be found. This should very rarely happen..."
            return 0, 0
        
        rr = rr(q, q)
    
        # solutions
        soly = rr.roots()
    
        if len(soly) == 0:
            print "Your prediction (delta) is too small"
            return 0, 0
    
        soly = soly[0][0]
        ss = pol1(q, soly)
        solx = ss.roots()[0][0]
    
        #
        return solx, soly
    
    def example():
        #
        # The problem to solve (edit the following values)
        #
    
        # the modulus
        N = 0xbadd260d14ea665b62e7d2e634f20a6382ac369cd44017305b69cf3a2694667ee651acded7085e0757d169b090f29f3f86fec255746674ffa8a6a3e1c9e1861003eb39f82cf74d84cc18e345f60865f998b33fc182a1a4ffa71f5ae48a1b5cb4c5f154b0997dc9b001e441815ce59c6c825f064fdca678858758dc2cebbc4d27
        # the public exponent
        e = 0x11722b54dd6f3ad9ce81da6f6ecb0acaf2cbc3885841d08b32abc0672d1a7293f9856db8f9407dc05f6f373a2d9246752a7cc7b1b6923f1827adfaeefc811e6e5989cce9f00897cfc1fc57987cce4862b5343bc8e91ddf2bd9e23aea9316a69f28f407cfe324d546a7dde13eb0bd052f694aefe8ec0f5298800277dbab4a33bb
    
        # the hypothesis on the private exponent (the theoretical maximum is 0.292)
        delta = .18 # this means that d < N^delta
    
        #
        # Lattice (tweak those values)
        #
    
        # you should tweak this (after a first run), (e.g. increment it until a solution is found)
        m = 4 # size of the lattice (bigger the better/slower)
    
        # you need to be a lattice master to tweak these
        t = int((1-2*delta) * m)  # optimization from Herrmann and May
        X = 2*floor(N^delta)  # this _might_ be too much
        Y = floor(N^(1/2))    # correct if p, q are ~ same size
    
        #
        # Don't touch anything below
        #
    
        # Problem put in equation
        P.<x,y> = PolynomialRing(ZZ)
        A = int((N+1)/2)
        pol = 1 + x * (A + y)
    
        #
        # Find the solutions!
        #
    
        # Checking bounds
        if debug:
            print "=== checking values ==="
            print "* delta:", delta
            print "* delta < 0.292", delta < 0.292
            print "* size of e:", int(log(e)/log(2))
            print "* size of N:", int(log(N)/log(2))
            print "* m:", m, ", t:", t
    
        # boneh_durfee
        if debug:
            print "=== running algorithm ==="
            start_time = time.time()
    
        solx, soly = boneh_durfee(pol, e, m, t, X, Y)
    
        # found a solution?
        if solx > 0:
            print "=== solution found ==="
            if False:
                print "x:", solx
                print "y:", soly
    
            d = int(pol(solx, soly) / e)
            print "private key found:", d
        else:
            print "=== no solution was found ==="
    
        if debug:
            print("=== %s seconds ===" % (time.time() - start_time))
    
    if __name__ == "__main__":
        example()
    
    ```

* 打强网杯学了点新姿势，证明过程日后再补
